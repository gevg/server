// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/goa-fhir/server/design
// --out=$(GOPATH)\src\github.com\goa-fhir\server
// --version=v1.1.0-dirty
//
// API "Secure": NutritionRequest Resource Client
//
// The content of this file is auto-generated, DO NOT MODIFY

package client

import (
	"bytes"
	"fmt"
	"golang.org/x/net/context"
	"golang.org/x/net/websocket"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// CreateNutritionRequestPayload is the NutritionRequest create action payload.
type CreateNutritionRequestPayload struct {
	// A link to a record of allergies or intolerances  which should be included in the nutrition order.
	AllergyIntolerance []*HL7Reference `form:"allergyIntolerance,omitempty" json:"allergyIntolerance,omitempty" xml:"allergyIntolerance,omitempty"`
	// The date and time that this nutrition order was requested.
	DateTime *time.Time `form:"dateTime,omitempty" json:"dateTime,omitempty" xml:"dateTime,omitempty"`
	// An encounter that provides additional information about the healthcare context in which this request is made.
	Encounter *HL7Reference `form:"encounter,omitempty" json:"encounter,omitempty" xml:"encounter,omitempty"`
	// Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
	EnteralFormula *EnteralFormula `form:"enteralFormula,omitempty" json:"enteralFormula,omitempty" xml:"enteralFormula,omitempty"`
	// This modifier is used to convey order-specific modifiers about the type of food that should NOT be given. These can be derived from
	// 		patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance
	// 		information captured in the referenced allergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be
	// 		eliminated from the patientâ€™s diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
	// 		See http://hl7.org/fhir/ValueSet/food-type
	ExcludeFoodModifier []*CodeableConcept `form:"excludeFoodModifier,omitempty" json:"excludeFoodModifier,omitempty" xml:"excludeFoodModifier,omitempty"`
	// This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived
	// 		from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional
	// 		supplements and enteral formula feedings. See http://hl7.org/fhir/ValueSet/encounter-diet
	FoodPreferenceModifier []*CodeableConcept `form:"foodPreferenceModifier,omitempty" json:"foodPreferenceModifier,omitempty" xml:"foodPreferenceModifier,omitempty"`
	// Identifiers assigned to this order by the order sender or by the order receiver.
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// The metadata about a resource. This is content in the resource that is maintained by the infrastructure.
	// 	Changes to the content may not always be associated with version changes to the resource.
	Meta *Meta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// Diet given orally in contrast to enteral (tube) feeding.
	OralDiet *OralDiet `form:"oralDiet,omitempty" json:"oralDiet,omitempty" xml:"oralDiet,omitempty"`
	// The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
	Orderer *HL7Reference `form:"orderer,omitempty" json:"orderer,omitempty" xml:"orderer,omitempty"`
	// The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
	Patient *HL7Reference `form:"patient,omitempty" json:"patient,omitempty" xml:"patient,omitempty"`
	// The workflow status of the nutrition order/request. See http://hl7.org/fhir/nutrition-request-status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Oral nutritional products given in order to add further nutritional value to the patient's diet.
	Supplement []*Supplement `form:"supplement,omitempty" json:"supplement,omitempty" xml:"supplement,omitempty"`
}

// CreateNutritionRequestPath computes a request path to the create action of NutritionRequest.
func CreateNutritionRequestPath(patientID int) string {
	param0 := strconv.Itoa(patientID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests", param0)
}

// Record new vital
func (c *Client) CreateNutritionRequest(ctx context.Context, path string, payload *CreateNutritionRequestPayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Response, error) {
	req, err := c.NewCreateNutritionRequestRequest(ctx, path, payload, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateNutritionRequestRequest create the request corresponding to the create action endpoint of the NutritionRequest resource.
func (c *Client) NewCreateNutritionRequestRequest(ctx context.Context, path string, payload *CreateNutritionRequestPayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp113 := strconv.Itoa(*count)
		values.Set("_count", tmp113)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp114 := strconv.Itoa(*id)
		values.Set("_id", tmp114)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp115 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp115)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// DeleteNutritionRequestPath computes a request path to the delete action of NutritionRequest.
func DeleteNutritionRequestPath(patientID int, nutritionRequestID int) string {
	param0 := strconv.Itoa(patientID)
	param1 := strconv.Itoa(nutritionRequestID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests/%s", param0, param1)
}

// DeleteNutritionRequest makes a request to the delete action endpoint of the NutritionRequest resource
func (c *Client) DeleteNutritionRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Response, error) {
	req, err := c.NewDeleteNutritionRequestRequest(ctx, path, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteNutritionRequestRequest create the request corresponding to the delete action endpoint of the NutritionRequest resource.
func (c *Client) NewDeleteNutritionRequestRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp116 := strconv.Itoa(*count)
		values.Set("_count", tmp116)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp117 := strconv.Itoa(*id)
		values.Set("_id", tmp117)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp118 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp118)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ListNutritionRequestPath computes a request path to the list action of NutritionRequest.
func ListNutritionRequestPath(patientID int) string {
	param0 := strconv.Itoa(patientID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests", param0)
}

// List all nutrition_requests in patient optionally filtering by year
func (c *Client) ListNutritionRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, years []int) (*http.Response, error) {
	req, err := c.NewListNutritionRequestRequest(ctx, path, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_, years)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListNutritionRequestRequest create the request corresponding to the list action endpoint of the NutritionRequest resource.
func (c *Client) NewListNutritionRequestRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, years []int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp119 := strconv.Itoa(*count)
		values.Set("_count", tmp119)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp120 := strconv.Itoa(*id)
		values.Set("_id", tmp120)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp121 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp121)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	for _, p := range years {
		tmp122 := strconv.Itoa(p)
		values.Add("years", tmp122)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// RateNutritionRequestPayload is the NutritionRequest rate action payload.
type RateNutritionRequestPayload struct {
	Rating string `form:"rating" json:"rating" xml:"rating"`
}

// RateNutritionRequestPath computes a request path to the rate action of NutritionRequest.
func RateNutritionRequestPath(patientID int, nutritionRequestID int) string {
	param0 := strconv.Itoa(patientID)
	param1 := strconv.Itoa(nutritionRequestID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests/%s/actions/rate", param0, param1)
}

// RateNutritionRequest makes a request to the rate action endpoint of the NutritionRequest resource
func (c *Client) RateNutritionRequest(ctx context.Context, path string, payload *RateNutritionRequestPayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Response, error) {
	req, err := c.NewRateNutritionRequestRequest(ctx, path, payload, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRateNutritionRequestRequest create the request corresponding to the rate action endpoint of the NutritionRequest resource.
func (c *Client) NewRateNutritionRequestRequest(ctx context.Context, path string, payload *RateNutritionRequestPayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp123 := strconv.Itoa(*count)
		values.Set("_count", tmp123)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp124 := strconv.Itoa(*id)
		values.Set("_id", tmp124)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp125 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp125)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReadNutritionRequestPath computes a request path to the read action of NutritionRequest.
func ReadNutritionRequestPath(patientID int, nutritionRequestID int) string {
	param0 := strconv.Itoa(patientID)
	param1 := strconv.Itoa(nutritionRequestID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests/%s", param0, param1)
}

// Retrieve vital with given id
func (c *Client) ReadNutritionRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Response, error) {
	req, err := c.NewReadNutritionRequestRequest(ctx, path, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewReadNutritionRequestRequest create the request corresponding to the read action endpoint of the NutritionRequest resource.
func (c *Client) NewReadNutritionRequestRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp126 := strconv.Itoa(*count)
		values.Set("_count", tmp126)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp127 := strconv.Itoa(*id)
		values.Set("_id", tmp127)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp128 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp128)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateNutritionRequestPath computes a request path to the update action of NutritionRequest.
func UpdateNutritionRequestPath(patientID int, nutritionRequestID int) string {
	param0 := strconv.Itoa(patientID)
	param1 := strconv.Itoa(nutritionRequestID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests/%s", param0, param1)
}

// UpdateNutritionRequest makes a request to the update action endpoint of the NutritionRequest resource
func (c *Client) UpdateNutritionRequest(ctx context.Context, path string, payload *NutritionRequestPayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Response, error) {
	req, err := c.NewUpdateNutritionRequestRequest(ctx, path, payload, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateNutritionRequestRequest create the request corresponding to the update action endpoint of the NutritionRequest resource.
func (c *Client) NewUpdateNutritionRequestRequest(ctx context.Context, path string, payload *NutritionRequestPayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp129 := strconv.Itoa(*count)
		values.Set("_count", tmp129)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp130 := strconv.Itoa(*id)
		values.Set("_id", tmp130)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp131 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp131)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PATCH", u.String(), &body)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// WatchNutritionRequestPath computes a request path to the watch action of NutritionRequest.
func WatchNutritionRequestPath(patientID int, nutritionRequestID int) string {
	param0 := strconv.Itoa(patientID)
	param1 := strconv.Itoa(nutritionRequestID)

	return fmt.Sprintf("/nosh/patients/%s/nutrition.requests/%s/watch", param0, param1)
}

// Retrieve vital with given id
func (c *Client) WatchNutritionRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*websocket.Conn, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "ws"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp132 := strconv.Itoa(*count)
		values.Set("_count", tmp132)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp133 := strconv.Itoa(*id)
		values.Set("_id", tmp133)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp134 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp134)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	url_ := u.String()
	cfg, err := websocket.NewConfig(url_, url_)
	if err != nil {
		return nil, err
	}
	return websocket.DialConfig(cfg)
}
