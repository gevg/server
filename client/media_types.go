// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/goa-fhir/server/design
// --out=$(GOPATH)\src\github.com\goa-fhir\server
// --version=v1.1.0-dirty
//
// API "goa-FHIR": Application Media Types
//
// The content of this file is auto-generated, DO NOT MODIFY

package client

import (
	"github.com/goadesign/goa"
	"net/http"
	"time"
)

// AddressMedia media type (default view)
//
// Identifier: application/vnd.address+json; view=default
type AddressMedia struct {
	// The name of the city, town, village or other community or delivery center.
	City *string `form:"city,omitempty" json:"city,omitempty" xml:"city,omitempty"`
	// Country (can be ISO 3166 3 letter code)
	Country *string `form:"country,omitempty" json:"country,omitempty" xml:"country,omitempty"`
	// District is sometimes known as county, but in some regions 'county' in used in place of city (municipality), so county name should be conveyed in city instead.
	Distinct *string `form:"distinct,omitempty" json:"distinct,omitempty" xml:"distinct,omitempty"`
	// This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
	Line []string `form:"line,omitempty" json:"line,omitempty" xml:"line,omitempty"`
	// A postal code designating a region defined by the postal service.
	PostalCode *string `form:"postalCode,omitempty" json:"postalCode,omitempty" xml:"postalCode,omitempty"`
	// Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes).
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// Text representation of the address.
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
	// Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The use of an address
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
}

// Validate validates the AddressMedia media type instance.
func (mt *AddressMedia) Validate() (err error) {
	if mt.Type != nil {
		if !(*mt.Type == "postal" || *mt.Type == "physical" || *mt.Type == "both") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *mt.Type, []interface{}{"postal", "physical", "both"}))
		}
	}
	if mt.Use != nil {
		if !(*mt.Use == "home" || *mt.Use == "work" || *mt.Use == "temp" || *mt.Use == "old - purpose of this address") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"home", "work", "temp", "old - purpose of this address"}))
		}
	}
	return
}

// DecodeAddressMedia decodes the AddressMedia instance encoded in resp body.
func (c *Client) DecodeAddressMedia(resp *http.Response) (*AddressMedia, error) {
	var decoded AddressMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// AllergyIntoleranceMedia media type (default view)
//
// Identifier: application/vnd.allergy.intolerance+json; view=default
type AllergyIntoleranceMedia struct {
	// Category of the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-category
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// Estimate of the potential clinical harm, or seriousness, of the reaction to the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality
	Criticality *string `form:"criticality,omitempty" json:"criticality,omitempty" xml:"criticality,omitempty"`
	// This records identifiers associated with this allergy/intolerance concern that are defined by business processes and/or
	// 		used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// Represents the date and/or time of the last known occurrence of a reaction event.
	LastOccurence *time.Time `form:"lastOccurence,omitempty" json:"lastOccurence,omitempty" xml:"lastOccurence,omitempty"`
	// The metadata about a resource. This is content in the resource that is maintained by the infrastructure.
	// 	Changes to the content may not always be associated with version changes to the resource.
	Meta *Meta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// Additional narrative about the propensity for the Adverse Reaction, not captured in other fields..
	Note *Annotation `form:"note,omitempty" json:"note,omitempty" xml:"note,omitempty"`
	// Record of the date and/or time of the onset of the Allergy or Intolerance.
	Onset *time.Time `form:"onset,omitempty" json:"onset,omitempty" xml:"onset,omitempty"`
	// The patient who has the allergy or intolerance.
	Patient *HL7Reference `form:"patient,omitempty" json:"patient,omitempty" xml:"patient,omitempty"`
	// Details about each adverse reaction event linked to exposure to the identified Substance.
	Reaction *Reaction `form:"reaction,omitempty" json:"reaction,omitempty" xml:"reaction,omitempty"`
	// Date when the sensitivity was recorded.
	RecordedDate *time.Time `form:"recordedDate,omitempty" json:"recordedDate,omitempty" xml:"recordedDate,omitempty"`
	// Individual who recorded the record and takes responsibility for its conten.
	Recorder *HL7Reference `form:"recorder,omitempty" json:"recorder,omitempty" xml:"recorder,omitempty"`
	// The source of the information about the allergy that is recorded.
	Reporter *HL7Reference `form:"reporter,omitempty" json:"reporter,omitempty" xml:"reporter,omitempty"`
	// Assertion about certainty associated with a propensity, or potential risk, of a reaction to the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identification of the underlying physiological mechanism for the reaction risk. See http://hl7.org/fhir/ValueSet/allergy-intolerance-type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the AllergyIntoleranceMedia media type instance.
func (mt *AllergyIntoleranceMedia) Validate() (err error) {
	if mt.Category != nil {
		if !(*mt.Category == "food" || *mt.Category == "medication" || *mt.Category == "environment" || *mt.Category == "other") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.category`, *mt.Category, []interface{}{"food", "medication", "environment", "other"}))
		}
	}
	if mt.Criticality != nil {
		if !(*mt.Criticality == "CRITL" || *mt.Criticality == "CRITH" || *mt.Criticality == "CRITU") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.criticality`, *mt.Criticality, []interface{}{"CRITL", "CRITH", "CRITU"}))
		}
	}
	for _, e := range mt.Identifier {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if mt.Reaction != nil {
		if err2 := mt.Reaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Status != nil {
		if !(*mt.Status == "active" || *mt.Status == "unconfirmed" || *mt.Status == "confirmed" || *mt.Status == "inactive" || *mt.Status == "resolved" || *mt.Status == "refuted" || *mt.Status == "entered-in-error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"active", "unconfirmed", "confirmed", "inactive", "resolved", "refuted", "entered-in-error"}))
		}
	}
	if mt.Type != nil {
		if !(*mt.Type == "allergy" || *mt.Type == "intolerance") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *mt.Type, []interface{}{"allergy", "intolerance"}))
		}
	}
	return
}

// DecodeAllergyIntoleranceMedia decodes the AllergyIntoleranceMedia instance encoded in resp body.
func (c *Client) DecodeAllergyIntoleranceMedia(resp *http.Response) (*AllergyIntoleranceMedia, error) {
	var decoded AllergyIntoleranceMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// AnimalMedia media type (default view)
//
// Identifier: application/vnd.animal+json; view=default
type AnimalMedia struct {
	// Identifies the detailed categorization of the kind of animal. See http://hl7.org/fhir/ValueSet/animal-breeds
	Breed *CodeableConcept `form:"breed,omitempty" json:"breed,omitempty" xml:"breed,omitempty"`
	// Indicates the current state of the animal's reproductive organs. See http://hl7.org/fhir/ValueSet/animal-genderstatus
	GenderStatus *CodeableConcept `form:"genderStatus,omitempty" json:"genderStatus,omitempty" xml:"genderStatus,omitempty"`
	// Identifies the high level taxonomic categorization of the kind of animal. See http://hl7.org/fhir/ValueSet/animal-species
	Species *CodeableConcept `form:"species,omitempty" json:"species,omitempty" xml:"species,omitempty"`
}

// DecodeAnimalMedia decodes the AnimalMedia instance encoded in resp body.
func (c *Client) DecodeAnimalMedia(resp *http.Response) (*AnimalMedia, error) {
	var decoded AnimalMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// AnnotationMedia media type (default view)
//
// Identifier: application/vnd.annotation+json; view=default
type AnnotationMedia struct {
	// The individual responsible for making the annotation.
	AuthorReference *HL7Reference `form:"authorReference,omitempty" json:"authorReference,omitempty" xml:"authorReference,omitempty"`
	// The individual responsible for making the annotation.
	AuthorString *string `form:"authorString,omitempty" json:"authorString,omitempty" xml:"authorString,omitempty"`
	// Indicates when this particular annotation was made.
	Time *time.Time `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// DecodeAnnotationMedia decodes the AnnotationMedia instance encoded in resp body.
func (c *Client) DecodeAnnotationMedia(resp *http.Response) (*AnnotationMedia, error) {
	var decoded AnnotationMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// AttachmentMedia media type (default view)
//
// Identifier: application/vnd.attachment+json; view=default
type AttachmentMedia struct {
	// Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data.
	// 				Includes mime type parameters such as charset where appropriate. See http://www.rfc-editor.org/bcp/bcp13.txt
	ContentType *string `form:"contentType,omitempty" json:"contentType,omitempty" xml:"contentType,omitempty"`
	// The date that the attachment was first created.
	Creation *time.Time `form:"creation,omitempty" json:"creation,omitempty" xml:"creation,omitempty"`
	// The actual data of the attachment - a sequence of bytes. In XML, represented using base64.
	Data *string `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// The calculated hash of the data using SHA-1. Represented using base64.
	Hash *string `form:"hash,omitempty" json:"hash,omitempty" xml:"hash,omitempty"`
	// The number of bytes of data that make up this attachment.
	Size *int `form:"size,omitempty" json:"size,omitempty" xml:"size,omitempty"`
	// A label or set of text to display in place of the data.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// DecodeAttachmentMedia decodes the AttachmentMedia instance encoded in resp body.
func (c *Client) DecodeAttachmentMedia(resp *http.Response) (*AttachmentMedia, error) {
	var decoded AttachmentMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// BackboneElementMedia media type (default view)
//
// Identifier: application/vnd.backboneelement+json; view=default
type BackboneElementMedia struct {
	Element           *Element   `form:"element,omitempty" json:"element,omitempty" xml:"element,omitempty"`
	ModifierExtension *Extension `form:"modifierExtension,omitempty" json:"modifierExtension,omitempty" xml:"modifierExtension,omitempty"`
}

// Validate validates the BackboneElementMedia media type instance.
func (mt *BackboneElementMedia) Validate() (err error) {
	if mt.Element != nil {
		if err2 := mt.Element.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ModifierExtension != nil {
		if err2 := mt.ModifierExtension.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeBackboneElementMedia decodes the BackboneElementMedia instance encoded in resp body.
func (c *Client) DecodeBackboneElementMedia(resp *http.Response) (*BackboneElementMedia, error) {
	var decoded BackboneElementMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// CodeableConceptMedia media type (default view)
//
// Identifier: application/vnd.codeable.concept+json; view=default
type CodeableConceptMedia struct {
	// A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
	Coding []*Coding `form:"coding,omitempty" json:"coding,omitempty" xml:"coding,omitempty"`
	// The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the
	// 	version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured. And when the meaning is not
	// 	guaranteed to be consistent, the version SHOULD be exchanged.
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
}

// DecodeCodeableConceptMedia decodes the CodeableConceptMedia instance encoded in resp body.
func (c *Client) DecodeCodeableConceptMedia(resp *http.Response) (*CodeableConceptMedia, error) {
	var decoded CodeableConceptMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// CodingMedia media type (default view)
//
// Identifier: application/vnd.coding+json; view=default
type CodingMedia struct {
	// A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// A representation of the meaning of the code in the system, following the rules of the system.
	Display *string `form:"display,omitempty" json:"display,omitempty" xml:"display,omitempty"`
	// The identification of the code system that defines the meaning of the symbol in the code.Identity of the terminology system
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// Indicates that this coding was chosen by a user directly - i.e. off a pick list of available items (codes or displays).
	UserSelected *bool `form:"userSelected,omitempty" json:"userSelected,omitempty" xml:"userSelected,omitempty"`
	// The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the
	// 		version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured. And when the meaning is not
	// 		guaranteed to be consistent, the version SHOULD be exchanged.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// DecodeCodingMedia decodes the CodingMedia instance encoded in resp body.
func (c *Client) DecodeCodingMedia(resp *http.Response) (*CodingMedia, error) {
	var decoded CodingMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// CommunicationMedia media type (default view)
//
// Identifier: application/vnd.communication+json; view=default
type CommunicationMedia struct {
	// Patient's nominated care provider.
	CareProvider *HL7Reference `form:"careProvider,omitempty" json:"careProvider,omitempty" xml:"careProvider,omitempty"`
	// The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen
	// 		and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
	Language *CodeableConcept `form:"language,omitempty" json:"language,omitempty" xml:"language,omitempty"`
	// Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
	Preferred *bool `form:"preferred,omitempty" json:"preferred,omitempty" xml:"preferred,omitempty"`
}

// DecodeCommunicationMedia decodes the CommunicationMedia instance encoded in resp body.
func (c *Client) DecodeCommunicationMedia(resp *http.Response) (*CommunicationMedia, error) {
	var decoded CommunicationMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ComponentMedia media type (default view)
//
// Identifier: application/vnd.component+json; view=default
type ComponentMedia struct {
	// Describes what was observed. Sometimes this is called the observation 'code'. See http://hl7.org/fhir/ValueSet/observation-codes
	Code *CodeableConcept `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Provides a reason why the expected value in the element Observation.value[x] is missing. See http://hl7.org/fhir/ValueSet/observation-valueabsentreason
	DataAbsentReason     *CodeableConcept `form:"dataAbsentReason,omitempty" json:"dataAbsentReason,omitempty" xml:"dataAbsentReason,omitempty"`
	ReferenceRange       *string          `form:"referenceRange,omitempty" json:"referenceRange,omitempty" xml:"referenceRange,omitempty"`
	ValueAttachment      *Attachment      `form:"valueAttachment,omitempty" json:"valueAttachment,omitempty" xml:"valueAttachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `form:"valueCodeableConcept,omitempty" json:"valueCodeableConcept,omitempty" xml:"valueCodeableConcept,omitempty"`
	ValueDatTime         *time.Time       `form:"valueDatTime,omitempty" json:"valueDatTime,omitempty" xml:"valueDatTime,omitempty"`
	ValuePeriod          *Period          `form:"valuePeriod,omitempty" json:"valuePeriod,omitempty" xml:"valuePeriod,omitempty"`
	ValueQuantity        *Quantity        `form:"valueQuantity,omitempty" json:"valueQuantity,omitempty" xml:"valueQuantity,omitempty"`
	ValueRange           *Range           `form:"valueRange,omitempty" json:"valueRange,omitempty" xml:"valueRange,omitempty"`
	ValueSampledData     *SampleData      `form:"valueSampledData,omitempty" json:"valueSampledData,omitempty" xml:"valueSampledData,omitempty"`
	ValueTime            *time.Time       `form:"valueTime,omitempty" json:"valueTime,omitempty" xml:"valueTime,omitempty"`
}

// Validate validates the ComponentMedia media type instance.
func (mt *ComponentMedia) Validate() (err error) {
	if mt.ValueAttachment != nil {
		if err2 := mt.ValueAttachment.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueQuantity != nil {
		if err2 := mt.ValueQuantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueRange != nil {
		if err2 := mt.ValueRange.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueSampledData != nil {
		if err2 := mt.ValueSampledData.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeComponentMedia decodes the ComponentMedia instance encoded in resp body.
func (c *Client) DecodeComponentMedia(resp *http.Response) (*ComponentMedia, error) {
	var decoded ComponentMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// HL7ContactMedia media type (default view)
//
// Identifier: application/vnd.contact+json; view=default
type HL7ContactMedia struct {
	// Patient's nominated care provider.
	Address *Address `form:"address,omitempty" json:"address,omitempty" xml:"address,omitempty"`
	// Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
	Gender *string `form:"gender,omitempty" json:"gender,omitempty" xml:"gender,omitempty"`
	// A name associated with the contact person.
	Name *HumanName `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Organization on behalf of which the contact is acting or for which the contact is working.
	Organization *HL7Reference `form:"organization,omitempty" json:"organization,omitempty" xml:"organization,omitempty"`
	// The period during which this contact person or organization is valid to be contacted relating to this patient.
	Period *Period `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// The nature of the relationship between the patient and the contact person.
	Relationship *CodeableConcept `form:"relationship,omitempty" json:"relationship,omitempty" xml:"relationship,omitempty"`
	// Address for the contact person.
	Telecom *ContactPoint `form:"telecom,omitempty" json:"telecom,omitempty" xml:"telecom,omitempty"`
}

// Validate validates the HL7ContactMedia media type instance.
func (mt *HL7ContactMedia) Validate() (err error) {
	if mt.Address != nil {
		if err2 := mt.Address.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Gender != nil {
		if !(*mt.Gender == "male" || *mt.Gender == "female" || *mt.Gender == "other" || *mt.Gender == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.gender`, *mt.Gender, []interface{}{"male", "female", "other", "unknown"}))
		}
	}
	if mt.Name != nil {
		if err2 := mt.Name.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Telecom != nil {
		if err2 := mt.Telecom.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeHL7ContactMedia decodes the HL7ContactMedia instance encoded in resp body.
func (c *Client) DecodeHL7ContactMedia(resp *http.Response) (*HL7ContactMedia, error) {
	var decoded HL7ContactMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ContactPointMedia media type (default view)
//
// Identifier: application/vnd.contactpoint+json; view=default
type ContactPointMedia struct {
	// Specifies a preferred order in which to use a set of contacts. Contacts are ranked with lower values coming before higher values.
	Rank *int `form:"rank,omitempty" json:"rank,omitempty" xml:"rank,omitempty"`
	// Telecommunications form for contact point - what communications system is required to make use of the contact.
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// Identifies the purpose for the contact point.
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
	// The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
	Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the ContactPointMedia media type instance.
func (mt *ContactPointMedia) Validate() (err error) {
	if mt.System != nil {
		if !(*mt.System == "phone" || *mt.System == "fax" || *mt.System == "email" || *mt.System == "pager" || *mt.System == "other") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.system`, *mt.System, []interface{}{"phone", "fax", "email", "pager", "other"}))
		}
	}
	if mt.Use != nil {
		if !(*mt.Use == "home" || *mt.Use == "work" || *mt.Use == "temp" || *mt.Use == "old" || *mt.Use == "mobile") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"home", "work", "temp", "old", "mobile"}))
		}
	}
	return
}

// DecodeContactPointMedia decodes the ContactPointMedia instance encoded in resp body.
func (c *Client) DecodeContactPointMedia(resp *http.Response) (*ContactPointMedia, error) {
	var decoded ContactPointMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ElelmentMedia media type (default view)
//
// Identifier: application/vnd.element+json; view=default
type ElelmentMedia struct {
	Extension *Extension `form:"extension,omitempty" json:"extension,omitempty" xml:"extension,omitempty"`
	ID        *string    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Validate validates the ElelmentMedia media type instance.
func (mt *ElelmentMedia) Validate() (err error) {
	if mt.Extension != nil {
		if err2 := mt.Extension.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeElelmentMedia decodes the ElelmentMedia instance encoded in resp body.
func (c *Client) DecodeElelmentMedia(resp *http.Response) (*ElelmentMedia, error) {
	var decoded ElelmentMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// EnteralFormulaMedia media type (default view)
//
// Identifier: application/vnd.enteral.formula+json; view=default
type EnteralFormulaMedia struct {
	// Product or brand name of the enteral or infant formula
	AdditiveProductName *string `form:"additiveProductName,omitempty" json:"additiveProductName,omitempty" xml:"additiveProductName,omitempty"`
	// Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula.
	AdditiveType *CodeableConcept `form:"additiveType,omitempty" json:"additiveType,omitempty" xml:"additiveType,omitempty"`
	// Free text formula administration, feeding instructions or additional instructions or information.
	AdministrativeInstruction *string `form:"administrativeInstruction,omitempty" json:"administrativeInstruction,omitempty" xml:"administrativeInstruction,omitempty"`
	// The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula.
	BaseFormulaType *CodeableConcept `form:"baseFormulaType,omitempty" json:"baseFormulaType,omitempty" xml:"baseFormulaType,omitempty"`
	// Product or brand name of the enteral or infant formula
	BaseFormulatProdcutName *string `form:"baseFormulatProdcutName,omitempty" json:"baseFormulatProdcutName,omitempty" xml:"baseFormulatProdcutName,omitempty"`
	// The amount of energy (Calories) that the formula should provide per specified volume, typically per mL or fluid oz.
	// 	    For example, an infant may require a formula that provides 24 Calories per fluid ounce or an adult may require an enteral formula that provides 1.5 Calorie/mL.
	CaloricDensity *Quantity `form:"caloricDensity,omitempty" json:"caloricDensity,omitempty" xml:"caloricDensity,omitempty"`
	// The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours.
	MaxVolumeToDeliver *Quantity `form:"maxVolumeToDeliver,omitempty" json:"maxVolumeToDeliver,omitempty" xml:"maxVolumeToDeliver,omitempty"`
	// The route or physiological path of administration into the patient's gastrointestinal
	// 		tract for purposes of providing the formula feeding, e.g. nasogastric tube.
	RouteofAdministration *CodeableConcept `form:"routeofAdministration,omitempty" json:"routeofAdministration,omitempty" xml:"routeofAdministration,omitempty"`
}

// Validate validates the EnteralFormulaMedia media type instance.
func (mt *EnteralFormulaMedia) Validate() (err error) {
	if mt.CaloricDensity != nil {
		if err2 := mt.CaloricDensity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.MaxVolumeToDeliver != nil {
		if err2 := mt.MaxVolumeToDeliver.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeEnteralFormulaMedia decodes the EnteralFormulaMedia instance encoded in resp body.
func (c *Client) DecodeEnteralFormulaMedia(resp *http.Response) (*EnteralFormulaMedia, error) {
	var decoded EnteralFormulaMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ExtensionMedia media type (default view)
//
// Identifier: application/vnd.extension+json; view=default
type ExtensionMedia struct {
	ValueAddress         *Address         `form:"ValueAddress,omitempty" json:"ValueAddress,omitempty" xml:"ValueAddress,omitempty"`
	ValueAnnotation      *Annotation      `form:"ValueAnnotation,omitempty" json:"ValueAnnotation,omitempty" xml:"ValueAnnotation,omitempty"`
	ValueAttachment      *Attachment      `form:"ValueAttachment,omitempty" json:"ValueAttachment,omitempty" xml:"ValueAttachment,omitempty"`
	ValueBase64Binary    *string          `form:"ValueBase64Binary,omitempty" json:"ValueBase64Binary,omitempty" xml:"ValueBase64Binary,omitempty"`
	ValueBoolean         *bool            `form:"ValueBoolean,omitempty" json:"ValueBoolean,omitempty" xml:"ValueBoolean,omitempty"`
	ValueCode            *string          `form:"ValueCode,omitempty" json:"ValueCode,omitempty" xml:"ValueCode,omitempty"`
	ValueCodeableConcept *CodeableConcept `form:"ValueCodeableConcept,omitempty" json:"ValueCodeableConcept,omitempty" xml:"ValueCodeableConcept,omitempty"`
	ValueCoding          *Coding          `form:"ValueCoding,omitempty" json:"ValueCoding,omitempty" xml:"ValueCoding,omitempty"`
	ValueContactPoint    *string          `form:"ValueContactPoint,omitempty" json:"ValueContactPoint,omitempty" xml:"ValueContactPoint,omitempty"`
	ValueDate            *time.Time       `form:"ValueDate,omitempty" json:"ValueDate,omitempty" xml:"ValueDate,omitempty"`
	ValueDateTime        *time.Time       `form:"ValueDateTime,omitempty" json:"ValueDateTime,omitempty" xml:"ValueDateTime,omitempty"`
	ValueDecimal         *float64         `form:"ValueDecimal,omitempty" json:"ValueDecimal,omitempty" xml:"ValueDecimal,omitempty"`
	ValueHumanName       *HumanName       `form:"ValueHumanName,omitempty" json:"ValueHumanName,omitempty" xml:"ValueHumanName,omitempty"`
	ValueID              *string          `form:"ValueId,omitempty" json:"ValueId,omitempty" xml:"ValueId,omitempty"`
	ValueIdentifier      *Identifier      `form:"ValueIdentifier,omitempty" json:"ValueIdentifier,omitempty" xml:"ValueIdentifier,omitempty"`
	ValueInstant         *time.Time       `form:"ValueInstant,omitempty" json:"ValueInstant,omitempty" xml:"ValueInstant,omitempty"`
	ValueInteger         *int             `form:"ValueInteger,omitempty" json:"ValueInteger,omitempty" xml:"ValueInteger,omitempty"`
	ValueMarkdown        *string          `form:"ValueMarkdown,omitempty" json:"ValueMarkdown,omitempty" xml:"ValueMarkdown,omitempty"`
	ValueMeta            *Meta            `form:"ValueMeta,omitempty" json:"ValueMeta,omitempty" xml:"ValueMeta,omitempty"`
	ValueOid             *string          `form:"ValueOid,omitempty" json:"ValueOid,omitempty" xml:"ValueOid,omitempty"`
	ValuePeriod          *Period          `form:"ValuePeriod,omitempty" json:"ValuePeriod,omitempty" xml:"ValuePeriod,omitempty"`
	ValuePositiveInt     *float64         `form:"ValuePositiveInt,omitempty" json:"ValuePositiveInt,omitempty" xml:"ValuePositiveInt,omitempty"`
	ValueQuantity        *Quantity        `form:"ValueQuantity,omitempty" json:"ValueQuantity,omitempty" xml:"ValueQuantity,omitempty"`
	ValueRange           *string          `form:"ValueRange,omitempty" json:"ValueRange,omitempty" xml:"ValueRange,omitempty"`
	ValueRatio           *int             `form:"ValueRatio,omitempty" json:"ValueRatio,omitempty" xml:"ValueRatio,omitempty"`
	ValueReference       *HL7Reference    `form:"ValueReference,omitempty" json:"ValueReference,omitempty" xml:"ValueReference,omitempty"`
	ValueSampledData     *string          `form:"ValueSampledData,omitempty" json:"ValueSampledData,omitempty" xml:"ValueSampledData,omitempty"`
	ValueSignature       *string          `form:"ValueSignature,omitempty" json:"ValueSignature,omitempty" xml:"ValueSignature,omitempty"`
	ValueString          *string          `form:"ValueString,omitempty" json:"ValueString,omitempty" xml:"ValueString,omitempty"`
	ValueTime            *time.Time       `form:"ValueTime,omitempty" json:"ValueTime,omitempty" xml:"ValueTime,omitempty"`
	ValueTiming          *time.Time       `form:"ValueTiming,omitempty" json:"ValueTiming,omitempty" xml:"ValueTiming,omitempty"`
	ValueUnsignedInt     *float64         `form:"ValueUnsignedInt,omitempty" json:"ValueUnsignedInt,omitempty" xml:"ValueUnsignedInt,omitempty"`
	ValueURI             *string          `form:"ValueUri,omitempty" json:"ValueUri,omitempty" xml:"ValueUri,omitempty"`
	URL                  *string          `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// Validate validates the ExtensionMedia media type instance.
func (mt *ExtensionMedia) Validate() (err error) {
	if mt.ValueAddress != nil {
		if err2 := mt.ValueAddress.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueAttachment != nil {
		if err2 := mt.ValueAttachment.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueHumanName != nil {
		if err2 := mt.ValueHumanName.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueIdentifier != nil {
		if err2 := mt.ValueIdentifier.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueQuantity != nil {
		if err2 := mt.ValueQuantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeExtensionMedia decodes the ExtensionMedia instance encoded in resp body.
func (c *Client) DecodeExtensionMedia(resp *http.Response) (*ExtensionMedia, error) {
	var decoded ExtensionMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeErrorResponse decodes the ErrorResponse instance encoded in resp body.
func (c *Client) DecodeErrorResponse(resp *http.Response) (*goa.ErrorResponse, error) {
	var decoded goa.ErrorResponse
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OAuth2 error response, See https://tools.ietf.org/html/rfc6749#section-5.2 (default view)
//
// Identifier: application/vnd.goa.fhir.oauth2.error+json; view=default
type OAuth2ErrorMedia struct {
	// Error returned by authorization server
	Error string `form:"error" json:"error" xml:"error"`
	// Human readable ASCII text providing additional information
	ErrorDescription *string `form:"error_description,omitempty" json:"error_description,omitempty" xml:"error_description,omitempty"`
	// A URI identifying a human-readable web page with information about the error
	ErrorURI *string `form:"error_uri,omitempty" json:"error_uri,omitempty" xml:"error_uri,omitempty"`
}

// Validate validates the OAuth2ErrorMedia media type instance.
func (mt *OAuth2ErrorMedia) Validate() (err error) {
	if mt.Error == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "error"))
	}
	if !(mt.Error == "invalid_request" || mt.Error == "invalid_client" || mt.Error == "invalid_grant" || mt.Error == "unauthorized_client" || mt.Error == "unsupported_grant_type") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.error`, mt.Error, []interface{}{"invalid_request", "invalid_client", "invalid_grant", "unauthorized_client", "unsupported_grant_type"}))
	}
	return
}

// DecodeOAuth2ErrorMedia decodes the OAuth2ErrorMedia instance encoded in resp body.
func (c *Client) DecodeOAuth2ErrorMedia(resp *http.Response) (*OAuth2ErrorMedia, error) {
	var decoded OAuth2ErrorMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OAuth2 access token request successful response, See https://tools.ietf.org/html/rfc6749#section-5.1 (default view)
//
// Identifier: application/vnd.goa.fhir.oauth2.token+json; view=default
type TokenMedia struct {
	// The access token issued by the authorization server
	AccessToken string `form:"access_token" json:"access_token" xml:"access_token"`
	// The lifetime in seconds of the access token
	ExpiresIn *int `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// The refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// The scope of the access token
	Scope *string `form:"scope,omitempty" json:"scope,omitempty" xml:"scope,omitempty"`
	// The type of the token issued, e.g. "bearer" or "mac"
	TokenType string `form:"token_type" json:"token_type" xml:"token_type"`
}

// Validate validates the TokenMedia media type instance.
func (mt *TokenMedia) Validate() (err error) {
	if mt.AccessToken == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "access_token"))
	}
	if mt.TokenType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "token_type"))
	}
	return
}

// DecodeTokenMedia decodes the TokenMedia instance encoded in resp body.
func (c *Client) DecodeTokenMedia(resp *http.Response) (*TokenMedia, error) {
	var decoded TokenMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// The common media type to all request responses for this example (default view)
//
// Identifier: application/vnd.goa.fhir.security.success; view=default
type Success struct {
	// Always true
	OK bool `form:"ok" json:"ok" xml:"ok"`
}

// DecodeSuccess decodes the Success instance encoded in resp body.
func (c *Client) DecodeSuccess(resp *http.Response) (*Success, error) {
	var decoded Success
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// HumanNameMedia media type (default view)
//
// Identifier: application/vnd.humanname+json; view=default
type HumanNameMedia struct {
	// The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
	Family []string `form:"family,omitempty" json:"family,omitempty" xml:"family,omitempty"`
	// Given names (not always 'first'). Includes middle names
	Given []string `form:"given,omitempty" json:"given,omitempty" xml:"given,omitempty"`
	// Indicates the period of time when this name was valid for the named person.
	Period *Period `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
	Prefix []string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
	Suffix []string `form:"suffix,omitempty" json:"suffix,omitempty" xml:"suffix,omitempty"`
	// Identifies the purpose for this name.
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
}

// Validate validates the HumanNameMedia media type instance.
func (mt *HumanNameMedia) Validate() (err error) {
	if mt.Use != nil {
		if !(*mt.Use == "usual" || *mt.Use == "official" || *mt.Use == "temp" || *mt.Use == "nickname" || *mt.Use == "anonymous" || *mt.Use == "old" || *mt.Use == "maiden") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"usual", "official", "temp", "nickname", "anonymous", "old", "maiden"}))
		}
	}
	return
}

// DecodeHumanNameMedia decodes the HumanNameMedia instance encoded in resp body.
func (c *Client) DecodeHumanNameMedia(resp *http.Response) (*HumanNameMedia, error) {
	var decoded HumanNameMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// IdentifierMedia media type (default view)
//
// Identifier: application/vnd.identifier+json; view=default
type IdentifierMedia struct {
	// Organization that issued/manages the identifier.
	Assigner *HL7Reference `form:"assigner,omitempty" json:"assigner,omitempty" xml:"assigner,omitempty"`
	// Time period during which identifier is/was valid for use.
	Period *Period `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// Establishes the namespace in which set of possible id values is unique.
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// A coded type for the identifier that can be used to determine which identifier to use for a specific purpose. See http://hl7.org/fhir/ValueSet/identifier-type
	Type *CodeableConcept `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The purpose of this identifier. Use http://hl7.org/fhir/ValueSet/identifier-use
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
	// The portion of the identifier typically displayed to the user and which is unique within the context of the system.
	Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the IdentifierMedia media type instance.
func (mt *IdentifierMedia) Validate() (err error) {
	if mt.System != nil {
		if err2 := goa.ValidateFormat(goa.FormatURI, *mt.System); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.system`, *mt.System, goa.FormatURI, err2))
		}
	}
	if mt.Use != nil {
		if !(*mt.Use == "usual" || *mt.Use == "official" || *mt.Use == "temp" || *mt.Use == "secondary (If known)") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"usual", "official", "temp", "secondary (If known)"}))
		}
	}
	return
}

// DecodeIdentifierMedia decodes the IdentifierMedia instance encoded in resp body.
func (c *Client) DecodeIdentifierMedia(resp *http.Response) (*IdentifierMedia, error) {
	var decoded IdentifierMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// PatientLinkMedia media type (default view)
//
// Identifier: application/vnd.link+json; view=default
type PatientLinkMedia struct {
	Other *string `form:"other,omitempty" json:"other,omitempty" xml:"other,omitempty"`
	Type  *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// DecodePatientLinkMedia decodes the PatientLinkMedia instance encoded in resp body.
func (c *Client) DecodePatientLinkMedia(resp *http.Response) (*PatientLinkMedia, error) {
	var decoded PatientLinkMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// MetaMedia media type (default view)
//
// Identifier: application/vnd.meta+json; view=default
type MetaMedia struct {
	// When the resource last changed - e.g. when the version changed.
	LastUpdated *time.Time `form:"lastUpdated,omitempty" json:"lastUpdated,omitempty" xml:"lastUpdated,omitempty"`
	// A list of profiles [[[StructureDefinition]]]s that this resource claims to conform to. The URL is a reference to [[[StructureDefinition.url]]].
	Profile []string `form:"profile,omitempty" json:"profile,omitempty" xml:"profile,omitempty"`
	// Security labels applied to this resource. These tags connect specific resources to the overall security policy and infrastructure.
	Security []*Coding `form:"security,omitempty" json:"security,omitempty" xml:"security,omitempty"`
	// Tags applied to this resource. Tags are intended to be used to identify and relate resources to process and workflow, and applications are not required to consider the tags when interpreting the meaning of a resource.
	Tag []*Coding `form:"tag,omitempty" json:"tag,omitempty" xml:"tag,omitempty"`
	// The version specific identifier, as it appears in the version portion of the URL. This values changes when the resource is created, updated, or deleted.
	VersionID *string `form:"versionId,omitempty" json:"versionId,omitempty" xml:"versionId,omitempty"`
}

// DecodeMetaMedia decodes the MetaMedia instance encoded in resp body.
func (c *Client) DecodeMetaMedia(resp *http.Response) (*MetaMedia, error) {
	var decoded MetaMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// NutrientMedia media type (default view)
//
// Identifier: application/vnd.nutrient+json; view=default
type NutrientMedia struct {
	// The quantity of the specified nutrient to include in diet.
	Amount *Quantity `form:"amount,omitempty" json:"amount,omitempty" xml:"amount,omitempty"`
	// The nutrient that is being modified such as carbohydrate or sodium. See http://hl7.org/fhir/ValueSet/nutrient-code
	Modifier *CodeableConcept `form:"modifier,omitempty" json:"modifier,omitempty" xml:"modifier,omitempty"`
}

// Validate validates the NutrientMedia media type instance.
func (mt *NutrientMedia) Validate() (err error) {
	if mt.Amount != nil {
		if err2 := mt.Amount.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeNutrientMedia decodes the NutrientMedia instance encoded in resp body.
func (c *Client) DecodeNutrientMedia(resp *http.Response) (*NutrientMedia, error) {
	var decoded NutrientMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// NutritionRequestMedia media type (default view)
//
// Identifier: application/vnd.nutrition.request+json; view=default
type NutritionRequestMedia struct {
	// A link to a record of allergies or intolerances  which should be included in the nutrition order.
	AllergyIntolerance []*HL7Reference `form:"allergyIntolerance,omitempty" json:"allergyIntolerance,omitempty" xml:"allergyIntolerance,omitempty"`
	// The date and time that this nutrition order was requested.
	DateTime *time.Time `form:"dateTime,omitempty" json:"dateTime,omitempty" xml:"dateTime,omitempty"`
	// An encounter that provides additional information about the healthcare context in which this request is made.
	Encounter *HL7Reference `form:"encounter,omitempty" json:"encounter,omitempty" xml:"encounter,omitempty"`
	// Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
	EnteralFormula *EnteralFormula `form:"enteralFormula,omitempty" json:"enteralFormula,omitempty" xml:"enteralFormula,omitempty"`
	// This modifier is used to convey order-specific modifiers about the type of food that should NOT be given. These can be derived from
	// 		patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance
	// 		information captured in the referenced allergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be
	// 		eliminated from the patient’s diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
	// 		See http://hl7.org/fhir/ValueSet/food-type
	ExcludeFoodModifier []*CodeableConcept `form:"excludeFoodModifier,omitempty" json:"excludeFoodModifier,omitempty" xml:"excludeFoodModifier,omitempty"`
	// This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived
	// 		from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional
	// 		supplements and enteral formula feedings. See http://hl7.org/fhir/ValueSet/encounter-diet
	FoodPreferenceModifier []*CodeableConcept `form:"foodPreferenceModifier,omitempty" json:"foodPreferenceModifier,omitempty" xml:"foodPreferenceModifier,omitempty"`
	// Identifiers assigned to this order by the order sender or by the order receiver.
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// The metadata about a resource. This is content in the resource that is maintained by the infrastructure.
	// 	Changes to the content may not always be associated with version changes to the resource.
	Meta *Meta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// Diet given orally in contrast to enteral (tube) feeding.
	OralDiet *OralDiet `form:"oralDiet,omitempty" json:"oralDiet,omitempty" xml:"oralDiet,omitempty"`
	// The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
	Orderer *HL7Reference `form:"orderer,omitempty" json:"orderer,omitempty" xml:"orderer,omitempty"`
	// The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
	Patient *HL7Reference `form:"patient,omitempty" json:"patient,omitempty" xml:"patient,omitempty"`
	// The workflow status of the nutrition order/request. See http://hl7.org/fhir/nutrition-request-status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Oral nutritional products given in order to add further nutritional value to the patient's diet.
	Supplement []*Supplement `form:"supplement,omitempty" json:"supplement,omitempty" xml:"supplement,omitempty"`
}

// Validate validates the NutritionRequestMedia media type instance.
func (mt *NutritionRequestMedia) Validate() (err error) {
	if mt.EnteralFormula != nil {
		if err2 := mt.EnteralFormula.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range mt.Identifier {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if mt.OralDiet != nil {
		if err2 := mt.OralDiet.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Status != nil {
		if !(*mt.Status == "proposed" || *mt.Status == "draft" || *mt.Status == "planned" || *mt.Status == "requested" || *mt.Status == "active" || *mt.Status == "on-hold" || *mt.Status == "completed" || *mt.Status == "cancelled") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"proposed", "draft", "planned", "requested", "active", "on-hold", "completed", "cancelled"}))
		}
	}
	for _, e := range mt.Supplement {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeNutritionRequestMedia decodes the NutritionRequestMedia instance encoded in resp body.
func (c *Client) DecodeNutritionRequestMedia(resp *http.Response) (*NutritionRequestMedia, error) {
	var decoded NutritionRequestMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ObservationMedia media type (default view)
//
// Identifier: application/vnd.observation+json; view=default
type ObservationMedia struct {
	// Indicates the site on the subject's body where the observation was made (i.e. the target site). See http://hl7.org/fhir/ValueSet/body-site
	BodySite *CodeableConcept `form:"bodySite,omitempty" json:"bodySite,omitempty" xml:"bodySite,omitempty"`
	// A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes. See http://hl7.org/fhir/ValueSet/observation-category
	Category *CodeableConcept `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// Describes what was observed. Sometimes this is called the observation 'name'. See http://hl7.org/fhir/ValueSet/observation-codes
	Code *CodeableConcept `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
	Comments *string `form:"comments,omitempty" json:"comments,omitempty" xml:"comments,omitempty"`
	// Some observations have multiple component observations.  These component observations are expressed as separate code
	// 		value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple
	// 		component observations for genetics observations.
	Component []*Component `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Provides a reason why the expected value in the element Observation.value[x] is missing. See http://hl7.org/fhir/ValueSet/observation-valueabsentreason
	DateAbsentReason *CodeableConcept `form:"dateAbsentReason,omitempty" json:"dateAbsentReason,omitempty" xml:"dateAbsentReason,omitempty"`
	// The device used to generate the observation data.
	Device *HL7Reference `form:"device,omitempty" json:"device,omitempty" xml:"device,omitempty"`
	// The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients -
	// 		this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection,
	// 		but very often the source of the date/time is not known, only the date/time itself.
	EffectiveDateTime *time.Time `form:"effectiveDateTime,omitempty" json:"effectiveDateTime,omitempty" xml:"effectiveDateTime,omitempty"`
	// The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients -
	// 		this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection,
	// 		but very often the source of the date/time is not known, only the date/time itself.
	EffectivePeriod *Period `form:"effectivePeriod,omitempty" json:"effectivePeriod,omitempty" xml:"effectivePeriod,omitempty"`
	// The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made.
	Encounter *HL7Reference `form:"encounter,omitempty" json:"encounter,omitempty" xml:"encounter,omitempty"`
	// A unique identifier for the simple observation instance.
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// The assessment made based on the result of the observation.  Intended as a simple compact code often
	// 		placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag.
	// 		See http://hl7.org/fhir/ValueSet/observation-interpretation
	Interpretation *CodeableConcept `form:"interpretation,omitempty" json:"interpretation,omitempty" xml:"interpretation,omitempty"`
	// The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
	Issued *time.Time `form:"issued,omitempty" json:"issued,omitempty" xml:"issued,omitempty"`
	// The metadata about a resource. This is content in the resource that is maintained by the infrastructure.
	// 	Changes to the content may not always be associated with version changes to the resource.
	Meta *Meta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// Indicates the mechanism used to perform the observation. See http://hl7.org/fhir/ValueSet/observation-methods
	Method *CodeableConcept `form:"method,omitempty" json:"method,omitempty" xml:"method,omitempty"`
	// Who was responsible for asserting the observed value as 'true'.
	Performer []*HL7Reference `form:"performer,omitempty" json:"performer,omitempty" xml:"performer,omitempty"`
	// Guidance on how to interpret the value by comparison to a normal or recommended range.
	ReferenceRange []*ReferenceRange `form:"referenceRange,omitempty" json:"referenceRange,omitempty" xml:"referenceRange,omitempty"`
	// A  reference to another resource (usually another Observation but could  also be a QuestionnaireAnswer) whose relationship is defined by the relationship type code.
	Related []*Related `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	// The specimen that was used when this observation was made.
	Specimen *HL7Reference `form:"specimen,omitempty" json:"specimen,omitempty" xml:"specimen,omitempty"`
	// The status of the result value. See http://hl7.org/fhir/ValueSet/observation-status
	Status               *string          `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	ValueAttachment      *Attachment      `form:"valueAttachment,omitempty" json:"valueAttachment,omitempty" xml:"valueAttachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `form:"valueCodeableConcept,omitempty" json:"valueCodeableConcept,omitempty" xml:"valueCodeableConcept,omitempty"`
	ValueDatTime         *time.Time       `form:"valueDatTime,omitempty" json:"valueDatTime,omitempty" xml:"valueDatTime,omitempty"`
	ValuePeriod          *Period          `form:"valuePeriod,omitempty" json:"valuePeriod,omitempty" xml:"valuePeriod,omitempty"`
	ValueQuantity        *Quantity        `form:"valueQuantity,omitempty" json:"valueQuantity,omitempty" xml:"valueQuantity,omitempty"`
	ValueRange           *Range           `form:"valueRange,omitempty" json:"valueRange,omitempty" xml:"valueRange,omitempty"`
	ValueSampledData     *SampleData      `form:"valueSampledData,omitempty" json:"valueSampledData,omitempty" xml:"valueSampledData,omitempty"`
	ValueString          *string          `form:"valueString,omitempty" json:"valueString,omitempty" xml:"valueString,omitempty"`
	ValueTime            *time.Time       `form:"valueTime,omitempty" json:"valueTime,omitempty" xml:"valueTime,omitempty"`
}

// Validate validates the ObservationMedia media type instance.
func (mt *ObservationMedia) Validate() (err error) {
	for _, e := range mt.Component {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.Identifier {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.ReferenceRange {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if mt.Status != nil {
		if !(*mt.Status == "registered" || *mt.Status == "preliminary" || *mt.Status == "final" || *mt.Status == "amended +") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"registered", "preliminary", "final", "amended +"}))
		}
	}
	if mt.ValueAttachment != nil {
		if err2 := mt.ValueAttachment.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueQuantity != nil {
		if err2 := mt.ValueQuantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueRange != nil {
		if err2 := mt.ValueRange.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueSampledData != nil {
		if err2 := mt.ValueSampledData.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeObservationMedia decodes the ObservationMedia instance encoded in resp body.
func (c *Client) DecodeObservationMedia(resp *http.Response) (*ObservationMedia, error) {
	var decoded ObservationMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OralDietMedia media type (default view)
//
// Identifier: application/vnd.oral.diet+json; view=default
type OralDietMedia struct {
	// The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient. See http://hl7.org/fhir/ValueSet/consistency-type
	FluidConsistencyType *CodeableConcept `form:"fluidConsistencyType,omitempty" json:"fluidConsistencyType,omitempty" xml:"fluidConsistencyType,omitempty"`
	// Free text or additional instructions or information pertaining to the oral diet.
	Instruction *string `form:"instruction,omitempty" json:"instruction,omitempty" xml:"instruction,omitempty"`
	// Class that defines the quantity and type of nutrient modifications required for the oral diet.
	Nutrient *Nutrient `form:"nutrient,omitempty" json:"nutrient,omitempty" xml:"nutrient,omitempty"`
	// The time period and frequency at which the diet should be given.
	Schedule *Timing `form:"schedule,omitempty" json:"schedule,omitempty" xml:"schedule,omitempty"`
	// Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
	Texture *Texture `form:"texture,omitempty" json:"texture,omitempty" xml:"texture,omitempty"`
	// The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet. See http://hl7.org/fhir/ValueSet/diet-type
	Type *CodeableConcept `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the OralDietMedia media type instance.
func (mt *OralDietMedia) Validate() (err error) {
	if mt.Nutrient != nil {
		if err2 := mt.Nutrient.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Schedule != nil {
		if err2 := mt.Schedule.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeOralDietMedia decodes the OralDietMedia instance encoded in resp body.
func (c *Client) DecodeOralDietMedia(resp *http.Response) (*OralDietMedia, error) {
	var decoded OralDietMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// PatientMedia media type (default view)
//
// Identifier: application/vnd.patient+json; view=default
type PatientMedia struct {
	// Whether this patient record is in active use.
	Active *bool `form:"active,omitempty" json:"active,omitempty" xml:"active,omitempty"`
	// Addresses for the individual.
	Address []*Address `form:"address,omitempty" json:"address,omitempty" xml:"address,omitempty"`
	// This patient is known to be an animal.
	Animal *Animal `form:"animal,omitempty" json:"animal,omitempty" xml:"animal,omitempty"`
	// The date of birth for the individual.
	BirthDate *time.Time `form:"birthDate,omitempty" json:"birthDate,omitempty" xml:"birthDate,omitempty"`
	// Patient's nominated primary care provider
	CareProvider *HL7Reference `form:"careProvider,omitempty" json:"careProvider,omitempty" xml:"careProvider,omitempty"`
	// Languages which may be used to communicate with the patient about his or her health.
	Communication []*Communication `form:"communication,omitempty" json:"communication,omitempty" xml:"communication,omitempty"`
	// A contact party (e.g. guardian, partner, friend) for the patient.
	Contact []*HL7Contact `form:"contact,omitempty" json:"contact,omitempty" xml:"contact,omitempty"`
	// Date of creation
	CreatedAt *time.Time `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Email of patient owner
	CreatedBy *string `form:"created_by,omitempty" json:"created_by,omitempty" xml:"created_by,omitempty"`
	// Indicates if the individual is deceased or not.
	DeceasedBoolean *bool `form:"deceasedBoolean,omitempty" json:"deceasedBoolean,omitempty" xml:"deceasedBoolean,omitempty"`
	// Indicates if the individual is deceased or not.
	DeceasedDateTime *time.Time   `form:"deceasedDateTime,omitempty" json:"deceasedDateTime,omitempty" xml:"deceasedDateTime,omitempty"`
	Extension        []*Extension `form:"extension,omitempty" json:"extension,omitempty" xml:"extension,omitempty"`
	// Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes. See http://hl7.org/fhir/ValueSet/administrative-gender
	Gender *string `form:"gender,omitempty" json:"gender,omitempty" xml:"gender,omitempty"`
	// API href of patient
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// Unique id for the element within a resource (for internal references).
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Patient identifer
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// Link to another patient resource that concerns the same actual patient.
	Link []*Link `form:"link,omitempty" json:"link,omitempty" xml:"link,omitempty"`
	// Organization that is the custodian of the patient record.
	ManagingOrganization *HL7Reference `form:"managingOrganization,omitempty" json:"managingOrganization,omitempty" xml:"managingOrganization,omitempty"`
	// The metadata about a resource. This is content in the resource that is maintained by the infrastructure.
	// 	Changes to the content may not always be associated with version changes to the resource.
	Meta *Meta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// Indicates whether the patient is part of a multiple or indicates the actual birth order..
	MultipleBirthBoolean *bool `form:"multipleBirthBoolean,omitempty" json:"multipleBirthBoolean,omitempty" xml:"multipleBirthBoolean,omitempty"`
	// Indicates whether the patient is part of a multiple or indicates the actual birth order..
	MultipleBirthInteger *int `form:"multipleBirthInteger,omitempty" json:"multipleBirthInteger,omitempty" xml:"multipleBirthInteger,omitempty"`
	// A name associated with the individual.
	Name []*HumanName `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Image of the patient.
	Photo        []*Attachment `form:"photo,omitempty" json:"photo,omitempty" xml:"photo,omitempty"`
	ResourceType *string       `form:"resourceType,omitempty" json:"resourceType,omitempty" xml:"resourceType,omitempty"`
	// A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted..
	Telecom []*ContactPoint `form:"telecom,omitempty" json:"telecom,omitempty" xml:"telecom,omitempty"`
}

// Validate validates the PatientMedia media type instance.
func (mt *PatientMedia) Validate() (err error) {
	for _, e := range mt.Address {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.Contact {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if mt.CreatedBy != nil {
		if err2 := goa.ValidateFormat(goa.FormatEmail, *mt.CreatedBy); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.created_by`, *mt.CreatedBy, goa.FormatEmail, err2))
		}
	}
	for _, e := range mt.Extension {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if mt.Gender != nil {
		if !(*mt.Gender == "male" || *mt.Gender == "female" || *mt.Gender == "other" || *mt.Gender == "unknown") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.gender`, *mt.Gender, []interface{}{"male", "female", "other", "unknown"}))
		}
	}
	for _, e := range mt.Identifier {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.Link {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.Name {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.Photo {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range mt.Telecom {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// PatientMedia media type (link view)
//
// Identifier: application/vnd.patient+json; view=link
type PatientMediaLink struct {
	// API href of patient
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// Unique id for the element within a resource (for internal references).
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DecodePatientMedia decodes the PatientMedia instance encoded in resp body.
func (c *Client) DecodePatientMedia(resp *http.Response) (*PatientMedia, error) {
	var decoded PatientMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodePatientMediaLink decodes the PatientMediaLink instance encoded in resp body.
func (c *Client) DecodePatientMediaLink(resp *http.Response) (*PatientMediaLink, error) {
	var decoded PatientMediaLink
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// PatientMediaCollection is the media type for an array of PatientMedia (default view)
//
// Identifier: application/vnd.patient+json; type=collection; view=default
type PatientMediaCollection []*PatientMedia

// Validate validates the PatientMediaCollection media type instance.
func (mt PatientMediaCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodePatientMediaCollection decodes the PatientMediaCollection instance encoded in resp body.
func (c *Client) DecodePatientMediaCollection(resp *http.Response) (PatientMediaCollection, error) {
	var decoded PatientMediaCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// PeriodMedia media type (default view)
//
// Identifier: application/vnd.period+json; view=default
type PeriodMedia struct {
	// End time with inclusive boundary, if not ongoing
	End *time.Time `form:"end,omitempty" json:"end,omitempty" xml:"end,omitempty"`
	// Starting time with inclusive boundary
	Start *time.Time `form:"start,omitempty" json:"start,omitempty" xml:"start,omitempty"`
}

// DecodePeriodMedia decodes the PeriodMedia instance encoded in resp body.
func (c *Client) DecodePeriodMedia(resp *http.Response) (*PeriodMedia, error) {
	var decoded PeriodMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// QuantityMedia media type (default view)
//
// Identifier: application/vnd.quantity+json; view=default
type QuantityMedia struct {
	// A computer processable form of the unit in some unit representation system.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues;
	// 		e.g. if the comparator is "<" , then the real value is < stated value. See http://hl7.org/fhir/ValueSet/quantity-comparator
	Comparator *string `form:"comparator,omitempty" json:"comparator,omitempty" xml:"comparator,omitempty"`
	// The identification of the system that provides the coded form of the unit.
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// A human-readable form of the unit.
	Unit *string `form:"unit,omitempty" json:"unit,omitempty" xml:"unit,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the QuantityMedia media type instance.
func (mt *QuantityMedia) Validate() (err error) {
	if mt.Comparator != nil {
		if !(*mt.Comparator == "<" || *mt.Comparator == "<=" || *mt.Comparator == ">=" || *mt.Comparator == ">") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.comparator`, *mt.Comparator, []interface{}{"<", "<=", ">=", ">"}))
		}
	}
	if mt.System != nil {
		if err2 := goa.ValidateFormat(goa.FormatURI, *mt.System); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.system`, *mt.System, goa.FormatURI, err2))
		}
	}
	return
}

// DecodeQuantityMedia decodes the QuantityMedia instance encoded in resp body.
func (c *Client) DecodeQuantityMedia(resp *http.Response) (*QuantityMedia, error) {
	var decoded QuantityMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RangeMedia media type (default view)
//
// Identifier: application/vnd.range+json; view=default
type RangeMedia struct {
	// The high limit. The boundary is inclusive.
	High *Quantity `form:"high,omitempty" json:"high,omitempty" xml:"high,omitempty"`
	// The low limit. The boundary is inclusive.
	Low *Quantity `form:"low,omitempty" json:"low,omitempty" xml:"low,omitempty"`
}

// Validate validates the RangeMedia media type instance.
func (mt *RangeMedia) Validate() (err error) {
	if mt.High != nil {
		if err2 := mt.High.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Low != nil {
		if err2 := mt.Low.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeRangeMedia decodes the RangeMedia instance encoded in resp body.
func (c *Client) DecodeRangeMedia(resp *http.Response) (*RangeMedia, error) {
	var decoded RangeMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RatioMedia media type (default view)
//
// Identifier: application/vnd.ratio+json; view=default
type RatioMedia struct {
	// The value of the denominator.
	Denominator *Quantity `form:"denominator,omitempty" json:"denominator,omitempty" xml:"denominator,omitempty"`
	// The value of the numerator.
	Numerator *Quantity `form:"numerator,omitempty" json:"numerator,omitempty" xml:"numerator,omitempty"`
}

// Validate validates the RatioMedia media type instance.
func (mt *RatioMedia) Validate() (err error) {
	if mt.Denominator != nil {
		if err2 := mt.Denominator.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Numerator != nil {
		if err2 := mt.Numerator.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeRatioMedia decodes the RatioMedia instance encoded in resp body.
func (c *Client) DecodeRatioMedia(resp *http.Response) (*RatioMedia, error) {
	var decoded RatioMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ReactionMedia media type (default view)
//
// Identifier: application/vnd.reaction+json; view=default
type ReactionMedia struct {
	// Statement about the degree of clinical certainty that the specific substance was the cause of the manifestation in this reaction event. See http://hl7.org/fhir/ValueSet/reaction-event-certainty
	Certainty *string `form:"certainty,omitempty" json:"certainty,omitempty" xml:"certainty,omitempty"`
	// Text description about the reaction as a whole, including details of the manifestation if required.
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Identification of the route by which the subject was exposed to the substance. See http://hl7.org/fhir/ValueSet/route-codes
	ExposureRoute *CodeableConcept `form:"exposureRoute,omitempty" json:"exposureRoute,omitempty" xml:"exposureRoute,omitempty"`
	// Clinical symptoms and/or signs that are observed or associated with the adverse reaction event. See http://hl7.org/fhir/ValueSet/manifestation-codes
	Manifestation *CodeableConcept `form:"manifestation,omitempty" json:"manifestation,omitempty" xml:"manifestation,omitempty"`
	// Additional text about the adverse reaction event not captured in other fields.
	Note *Annotation `form:"note,omitempty" json:"note,omitempty" xml:"note,omitempty"`
	// Record of the date and/or time of the onset of the Reaction.
	Onset *time.Time `form:"onset,omitempty" json:"onset,omitempty" xml:"onset,omitempty"`
	// Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations. See http://hl7.org/fhir/ValueSet/reaction-event-severity
	Severity *string `form:"severity,omitempty" json:"severity,omitempty" xml:"severity,omitempty"`
	// Identification of the specific substance considered to be responsible for the Adverse Reaction event.
	// 		Note: the substance for a specific reaction may be different to the substance identified as the cause of the risk, but must be consistent with it.
	// 		For instance, it may be a more specific substance (e.g. a brand medication) or a composite substance that includes the identified substance.
	// 		It must be clinically safe to only process the AllergyIntolerance.substance and ignore the AllergyIntolerance.event.substance.
	Substance *CodeableConcept `form:"substance,omitempty" json:"substance,omitempty" xml:"substance,omitempty"`
}

// Validate validates the ReactionMedia media type instance.
func (mt *ReactionMedia) Validate() (err error) {
	if mt.Certainty != nil {
		if !(*mt.Certainty == "unlikely" || *mt.Certainty == "likely" || *mt.Certainty == "confirmed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.certainty`, *mt.Certainty, []interface{}{"unlikely", "likely", "confirmed"}))
		}
	}
	if mt.Severity != nil {
		if !(*mt.Severity == "mild" || *mt.Severity == "moderate" || *mt.Severity == "severe") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.severity`, *mt.Severity, []interface{}{"mild", "moderate", "severe"}))
		}
	}
	return
}

// DecodeReactionMedia decodes the ReactionMedia instance encoded in resp body.
func (c *Client) DecodeReactionMedia(resp *http.Response) (*ReactionMedia, error) {
	var decoded ReactionMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// HL7ReferenceMedia media type (default view)
//
// Identifier: application/vnd.reference+json; view=default
type HL7ReferenceMedia struct {
	// Plain text narrative that identifies the resource in addition to the resource reference.
	Display *string `form:"display,omitempty" json:"display,omitempty" xml:"display,omitempty"`
	// A reference to a location at which the other resource is found. The reference may be a relative reference, in which case it is relative to
	// 		the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is
	// 		not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with '#') refer to contained resources.
	Reference *string `form:"reference,omitempty" json:"reference,omitempty" xml:"reference,omitempty"`
}

// DecodeHL7ReferenceMedia decodes the HL7ReferenceMedia instance encoded in resp body.
func (c *Client) DecodeHL7ReferenceMedia(resp *http.Response) (*HL7ReferenceMedia, error) {
	var decoded HL7ReferenceMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ReferenceRangeMedia media type (default view)
//
// Identifier: application/vnd.reference.range+json; view=default
type ReferenceRangeMedia struct {
	// Time when observation was collected from subject - the physiologically relevant time.
	Age *Range `form:"age,omitempty" json:"age,omitempty" xml:"age,omitempty"`
	// The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value
	// 		(e.g.  reference range is >=5 - <=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3).
	High *Quantity `form:"high,omitempty" json:"high,omitempty" xml:"high,omitempty"`
	// The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value
	// 		(e.g.  reference range is >=5 - <=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3).
	Low *Quantity `form:"low,omitempty" json:"low,omitempty" xml:"low,omitempty"`
	// Code for the meaning of the reference range. See http://hl7.org/fhir/ValueSet/referencerange-meaning
	Meaning *CodeableConcept `form:"meaning,omitempty" json:"meaning,omitempty" xml:"meaning,omitempty"`
	// Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.
	// 		An example would be a reference value of "Negative" or a list or table of 'normals'.
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
}

// Validate validates the ReferenceRangeMedia media type instance.
func (mt *ReferenceRangeMedia) Validate() (err error) {
	if mt.Age != nil {
		if err2 := mt.Age.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.High != nil {
		if err2 := mt.High.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Low != nil {
		if err2 := mt.Low.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeReferenceRangeMedia decodes the ReferenceRangeMedia instance encoded in resp body.
func (c *Client) DecodeReferenceRangeMedia(resp *http.Response) (*ReferenceRangeMedia, error) {
	var decoded ReferenceRangeMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RelatedMedia media type (default view)
//
// Identifier: application/vnd.related+json; view=default
type RelatedMedia struct {
	// A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation.
	Target *CodeableConcept `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// A code specifying the kind of relationship that exists with the target resource. See http://hl7.org/fhir/ValueSet/observation-relationshiptypes
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// DecodeRelatedMedia decodes the RelatedMedia instance encoded in resp body.
func (c *Client) DecodeRelatedMedia(resp *http.Response) (*RelatedMedia, error) {
	var decoded RelatedMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RepeatMedia media type (default view)
//
// Identifier: application/vnd.repeat+json; view=default
type RepeatMedia struct {
	// Length/Range of lengths, or (Start and/or end) limits
	Bounds *interface{} `form:"bounds,omitempty" json:"bounds,omitempty" xml:"bounds,omitempty"`
	// A total count of the desired number of repetitions.
	Count *int `form:"count,omitempty" json:"count,omitempty" xml:"count,omitempty"`
	// How long this thing happens for when it happens.
	Duration *float64 `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The units of time for the duration, in UCUM units. See http://hl7.org/fhir/ValueSet/units-of-time
	DurationUnits *string `form:"durationUnits,omitempty" json:"durationUnits,omitempty" xml:"durationUnits,omitempty"`
	// The number of times to repeat the action within the specified period / period range (i.e. both period and periodMax provided).
	Frequency *int `form:"frequency,omitempty" json:"frequency,omitempty" xml:"frequency,omitempty"`
	// If present, indicates that the frequency is a range - so repeat between [frequency] and [frequencyMax] times within the period or period range.
	FrequencyMax *int `form:"frequencyMax,omitempty" json:"frequencyMax,omitempty" xml:"frequencyMax,omitempty"`
	// Event occurs frequency times per period
	Period *float64 `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as 'do this once every 3-5 days.'
	PeriodMax *string `form:"periodMax,omitempty" json:"periodMax,omitempty" xml:"periodMax,omitempty"`
	// The units of time for the period in UCUM units. See http://hl7.org/fhir/ValueSet/units-of-time
	PeriodUnits *string `form:"periodUnits,omitempty" json:"periodUnits,omitempty" xml:"periodUnits,omitempty"`
	// A real world event that the occurrence of the event should be tied to. See http://hl7.org/fhir/ValueSet/event-timing
	When *string `form:"when,omitempty" json:"when,omitempty" xml:"when,omitempty"`
}

// Validate validates the RepeatMedia media type instance.
func (mt *RepeatMedia) Validate() (err error) {
	if mt.DurationUnits != nil {
		if !(*mt.DurationUnits == "s" || *mt.DurationUnits == "min" || *mt.DurationUnits == "h" || *mt.DurationUnits == "d" || *mt.DurationUnits == "wk" || *mt.DurationUnits == "mo" || *mt.DurationUnits == "a") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.durationUnits`, *mt.DurationUnits, []interface{}{"s", "min", "h", "d", "wk", "mo", "a"}))
		}
	}
	if mt.PeriodUnits != nil {
		if !(*mt.PeriodUnits == "s" || *mt.PeriodUnits == "min" || *mt.PeriodUnits == "h" || *mt.PeriodUnits == "d" || *mt.PeriodUnits == "wk" || *mt.PeriodUnits == "mo" || *mt.PeriodUnits == "a") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.periodUnits`, *mt.PeriodUnits, []interface{}{"s", "min", "h", "d", "wk", "mo", "a"}))
		}
	}
	return
}

// DecodeRepeatMedia decodes the RepeatMedia instance encoded in resp body.
func (c *Client) DecodeRepeatMedia(resp *http.Response) (*RepeatMedia, error) {
	var decoded RepeatMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// SampleDataMedia media type (default view)
//
// Identifier: application/vnd.sample.data+json; view=default
type SampleDataMedia struct {
	// A series of data points which are decimal values separated by a single space (character u20). The special values 'E' (error), 'L' (below detection limit) and 'U' (above detection limit) can also be used in place of a decimal value.
	Data *string `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// The upper limit of detection of the measured points. This is needed if any of the data points have the value 'U' (higher than detection limit).
	Dimensions *int `form:"dimensions,omitempty" json:"dimensions,omitempty" xml:"dimensions,omitempty"`
	// A correction factor that is applied to the sampled data points before they are added to the origin.
	Factor *float64 `form:"factor,omitempty" json:"factor,omitempty" xml:"factor,omitempty"`
	// The lower limit of detection of the measured points. This is needed if any of the data points have the value 'L' (lower than detection limit).
	LowerLimit *float64 `form:"lowerLimit,omitempty" json:"lowerLimit,omitempty" xml:"lowerLimit,omitempty"`
	// The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
	Origin *Quantity `form:"origin,omitempty" json:"origin,omitempty" xml:"origin,omitempty"`
	// The length of time between sampling times, measured in milliseconds.
	Period *float64 `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// The upper limit of detection of the measured points. This is needed if any of the data points have the value 'U' (higher than detection limit).
	UpperLimit *float64 `form:"upperLimit,omitempty" json:"upperLimit,omitempty" xml:"upperLimit,omitempty"`
}

// Validate validates the SampleDataMedia media type instance.
func (mt *SampleDataMedia) Validate() (err error) {
	if mt.Origin != nil {
		if err2 := mt.Origin.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeSampleDataMedia decodes the SampleDataMedia instance encoded in resp body.
func (c *Client) DecodeSampleDataMedia(resp *http.Response) (*SampleDataMedia, error) {
	var decoded SampleDataMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// SignatureDataMedia media type (default view)
//
// Identifier: application/vnd.signature+json; view=default
type SignatureDataMedia struct {
	// The base64 encoding of the Signature content.
	Blob *string `form:"blob,omitempty" json:"blob,omitempty" xml:"blob,omitempty"`
	// A mime type that indicates the technical format of the signature. Important mime types are application/signature+
	// 		for X ML DigSig, application/jwt for JWT, and image/* for a graphical image of a signature. See http://www.rfc-editor.org/bcp/bcp13.txt
	ContentType *string `form:"contentType,omitempty" json:"contentType,omitempty" xml:"contentType,omitempty"`
	// An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature
	// 	information and can be used when determining accountability for various actions concerning the document. See http://hl7.org/fhir/ValueSet/signature-type
	Type *Coding `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// A reference to an application-usable description of the person that signed the certificate (e.g. the signature used their private key.
	When *time.Time `form:"when,omitempty" json:"when,omitempty" xml:"when,omitempty"`
	//  A reference to an application-usable description of the person that signed the certificate (e.g. the signature used their private key).
	WhoReference *HL7Reference `form:"whoReference,omitempty" json:"whoReference,omitempty" xml:"whoReference,omitempty"`
	// A reference to an application-usable description of the person that signed the certificate (e.g. the signature used their private key).
	WhoURI *string `form:"whoUri,omitempty" json:"whoUri,omitempty" xml:"whoUri,omitempty"`
}

// DecodeSignatureDataMedia decodes the SignatureDataMedia instance encoded in resp body.
func (c *Client) DecodeSignatureDataMedia(resp *http.Response) (*SignatureDataMedia, error) {
	var decoded SignatureDataMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// SupplementMedia media type (default view)
//
// Identifier: application/vnd.supplement+json; view=default
type SupplementMedia struct {
	// Free text or additional instructions or information pertaining to the oral supplement.
	Instruction *string `form:"instruction,omitempty" json:"instruction,omitempty" xml:"instruction,omitempty"`
	// The product or brand name of the nutritional supplement such as 'Acme Protein Shake'.
	ProductName *string `form:"productName,omitempty" json:"productName,omitempty" xml:"productName,omitempty"`
	// The amount of the nutritional supplement to be given.
	Quantity *Quantity `form:"quantity,omitempty" json:"quantity,omitempty" xml:"quantity,omitempty"`
	// The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement.
	Type *CodeableConcept `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the SupplementMedia media type instance.
func (mt *SupplementMedia) Validate() (err error) {
	if mt.Quantity != nil {
		if err2 := mt.Quantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeSupplementMedia decodes the SupplementMedia instance encoded in resp body.
func (c *Client) DecodeSupplementMedia(resp *http.Response) (*SupplementMedia, error) {
	var decoded SupplementMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// TextureMedia media type (default view)
//
// Identifier: application/vnd.texture+json; view=default
type TextureMedia struct {
	// The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. See http://hl7.org/fhir/ValueSet/modified-foodtype
	FoodType *CodeableConcept `form:"foodType,omitempty" json:"foodType,omitempty" xml:"foodType,omitempty"`
	// Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. See http://hl7.org/fhir/ValueSet/texture-code
	Modifier *CodeableConcept `form:"modifier,omitempty" json:"modifier,omitempty" xml:"modifier,omitempty"`
}

// DecodeTextureMedia decodes the TextureMedia instance encoded in resp body.
func (c *Client) DecodeTextureMedia(resp *http.Response) (*TextureMedia, error) {
	var decoded TextureMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// TimingMedia media type (default view)
//
// Identifier: application/vnd.timing+json; view=default
type TimingMedia struct {
	// A code for the timing pattern. Some codes such as BID are ubiquitous, but many institutions define their own additional codes. See http://hl7.org/fhir/ValueSet/timing-abbreviation
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Identifies specific times when the event occurs.
	Event *time.Time `form:"event,omitempty" json:"event,omitempty" xml:"event,omitempty"`
	// A set of rules that describe when the event should occur.
	Repeat *Element `form:"repeat,omitempty" json:"repeat,omitempty" xml:"repeat,omitempty"`
}

// Validate validates the TimingMedia media type instance.
func (mt *TimingMedia) Validate() (err error) {
	if mt.Code != nil {
		if !(*mt.Code == "QD" || *mt.Code == "QOD" || *mt.Code == "Q4H" || *mt.Code == "Q6H" || *mt.Code == "BID" || *mt.Code == "TID" || *mt.Code == "QID" || *mt.Code == "AM" || *mt.Code == "PM +") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.code`, *mt.Code, []interface{}{"QD", "QOD", "Q4H", "Q6H", "BID", "TID", "QID", "AM", "PM +"}))
		}
	}
	if mt.Repeat != nil {
		if err2 := mt.Repeat.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeTimingMedia decodes the TimingMedia instance encoded in resp body.
func (c *Client) DecodeTimingMedia(resp *http.Response) (*TimingMedia, error) {
	var decoded TimingMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// A user of the API (default view)
//
// Identifier: application/vnd.user+json; view=default
type UserMedia struct {
	// Name of city, town etc.
	AddressCity *string `form:"address_city,omitempty" json:"address_city,omitempty" xml:"address_city,omitempty"`
	// Street name, number, direction & P.O. Box etc.
	AddressLine *string `form:"address_line,omitempty" json:"address_line,omitempty" xml:"address_line,omitempty"`
	// Postal code for area
	AddressPostalCode *int `form:"address_postal_code,omitempty" json:"address_postal_code,omitempty" xml:"address_postal_code,omitempty"`
	// Sub-unit of country (abbreviations ok)
	AddressState *string `form:"address_state,omitempty" json:"address_state,omitempty" xml:"address_state,omitempty"`
	// Date of creation
	CreatedAt *time.Time `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Email of user owner
	CreatedBy *string `form:"created_by,omitempty" json:"created_by,omitempty" xml:"created_by,omitempty"`
	// Email of user
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// First name of user
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// API href of user
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// ID of user
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Last name of user
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// Username of user
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Validate validates the UserMedia media type instance.
func (mt *UserMedia) Validate() (err error) {
	if mt.CreatedBy != nil {
		if err2 := goa.ValidateFormat(goa.FormatEmail, *mt.CreatedBy); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.created_by`, *mt.CreatedBy, goa.FormatEmail, err2))
		}
	}
	if mt.Email != nil {
		if err2 := goa.ValidateFormat(goa.FormatEmail, *mt.Email); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.email`, *mt.Email, goa.FormatEmail, err2))
		}
	}
	return
}

// A user of the API (link view)
//
// Identifier: application/vnd.user+json; view=link
type UserMediaLink struct {
	// API href of user
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// ID of user
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// A user of the API (tiny view)
//
// Identifier: application/vnd.user+json; view=tiny
type UserMediaTiny struct {
	// Email of user
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// First name of user
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// API href of user
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// ID of user
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Last name of user
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// Username of user
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Validate validates the UserMediaTiny media type instance.
func (mt *UserMediaTiny) Validate() (err error) {
	if mt.Email != nil {
		if err2 := goa.ValidateFormat(goa.FormatEmail, *mt.Email); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.email`, *mt.Email, goa.FormatEmail, err2))
		}
	}
	return
}

// DecodeUserMedia decodes the UserMedia instance encoded in resp body.
func (c *Client) DecodeUserMedia(resp *http.Response) (*UserMedia, error) {
	var decoded UserMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeUserMediaLink decodes the UserMediaLink instance encoded in resp body.
func (c *Client) DecodeUserMediaLink(resp *http.Response) (*UserMediaLink, error) {
	var decoded UserMediaLink
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeUserMediaTiny decodes the UserMediaTiny instance encoded in resp body.
func (c *Client) DecodeUserMediaTiny(resp *http.Response) (*UserMediaTiny, error) {
	var decoded UserMediaTiny
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// UserMediaCollection is the media type for an array of UserMedia (default view)
//
// Identifier: application/vnd.user+json; type=collection; view=default
type UserMediaCollection []*UserMedia

// Validate validates the UserMediaCollection media type instance.
func (mt UserMediaCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// UserMediaCollection is the media type for an array of UserMedia (link view)
//
// Identifier: application/vnd.user+json; type=collection; view=link
type UserMediaLinkCollection []*UserMediaLink

// UserMediaCollection is the media type for an array of UserMedia (tiny view)
//
// Identifier: application/vnd.user+json; type=collection; view=tiny
type UserMediaTinyCollection []*UserMediaTiny

// Validate validates the UserMediaTinyCollection media type instance.
func (mt UserMediaTinyCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeUserMediaCollection decodes the UserMediaCollection instance encoded in resp body.
func (c *Client) DecodeUserMediaCollection(resp *http.Response) (UserMediaCollection, error) {
	var decoded UserMediaCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeUserMediaLinkCollection decodes the UserMediaLinkCollection instance encoded in resp body.
func (c *Client) DecodeUserMediaLinkCollection(resp *http.Response) (UserMediaLinkCollection, error) {
	var decoded UserMediaLinkCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeUserMediaTinyCollection decodes the UserMediaTinyCollection instance encoded in resp body.
func (c *Client) DecodeUserMediaTinyCollection(resp *http.Response) (UserMediaTinyCollection, error) {
	var decoded UserMediaTinyCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}
