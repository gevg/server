// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/goa-fhir/server/design
// --out=$(GOPATH)\src\github.com\goa-fhir\server
// --version=v1.1.0-dirty
//
// API "Secure": Application Media Types
//
// The content of this file is auto-generated, DO NOT MODIFY

package client

import (
	"github.com/goadesign/goa"
	"net/http"
	"time"
	"unicode/utf8"
)

// Address media type (default view)
//
// Identifier: application/vnd.address+json; view=default
type Address struct {
	// The name of the city, town, village or other community or delivery center.
	City *string `form:"city,omitempty" json:"city,omitempty" xml:"city,omitempty"`
	// Country (can be ISO 3166 3 letter code)
	Country *string `form:"country,omitempty" json:"country,omitempty" xml:"country,omitempty"`
	// District is sometimes known as county, but in some regions 'county' in used in place of city (municipality), so county name should be conveyed in city instead.
	Distinct *string `form:"distinct,omitempty" json:"distinct,omitempty" xml:"distinct,omitempty"`
	// This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
	Line *string `form:"line,omitempty" json:"line,omitempty" xml:"line,omitempty"`
	// A postal code designating a region defined by the postal service.
	PostalCode *int `form:"postalCode,omitempty" json:"postalCode,omitempty" xml:"postalCode,omitempty"`
	// Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes).
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The use of an address
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
}

// Validate validates the Address media type instance.
func (mt *Address) Validate() (err error) {
	if mt.Type != nil {
		if !(*mt.Type == "postal" || *mt.Type == "physical" || *mt.Type == "both") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *mt.Type, []interface{}{"postal", "physical", "both"}))
		}
	}
	if mt.Use != nil {
		if !(*mt.Use == "home" || *mt.Use == "work" || *mt.Use == "temp" || *mt.Use == "old - purpose of this address") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"home", "work", "temp", "old - purpose of this address"}))
		}
	}
	return
}

// DecodeAddress decodes the Address instance encoded in resp body.
func (c *Client) DecodeAddress(resp *http.Response) (*Address, error) {
	var decoded Address
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Allergy_intolerance media type (default view)
//
// Identifier: application/vnd.allergy_intolerance+json; view=default
type AllergyIntolerance struct {
	// Category of the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-category
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// Estimate of the potential clinical harm, or seriousness, of the reaction to the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality
	Criticality *string `form:"criticality,omitempty" json:"criticality,omitempty" xml:"criticality,omitempty"`
	// This records identifiers associated with this allergy/intolerance concern that are defined by business processes and/or
	// 		used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
	Identifier *Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// Represents the date and/or time of the last known occurrence of a reaction event.
	LastOccurence *time.Time `form:"lastOccurence,omitempty" json:"lastOccurence,omitempty" xml:"lastOccurence,omitempty"`
	// Additional narrative about the propensity for the Adverse Reaction, not captured in other fields..
	Note *Annotation `form:"note,omitempty" json:"note,omitempty" xml:"note,omitempty"`
	// Record of the date and/or time of the onset of the Allergy or Intolerance.
	Onset   *time.Time `form:"onset,omitempty" json:"onset,omitempty" xml:"onset,omitempty"`
	Orderer *struct {
		// xml:id (or equivalent in JSON)
		ID        *string    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
		Reference *Reference `form:"reference,omitempty" json:"reference,omitempty" xml:"reference,omitempty"`
	} `form:"orderer,omitempty" json:"orderer,omitempty" xml:"orderer,omitempty"`
	// The patient who has the allergy or intolerance.
	Patient *Reference `form:"patient,omitempty" json:"patient,omitempty" xml:"patient,omitempty"`
	// Details about each adverse reaction event linked to exposure to the identified Substance.
	Reaction *Reaction `form:"reaction,omitempty" json:"reaction,omitempty" xml:"reaction,omitempty"`
	// Date when the sensitivity was recorded.
	RecordedDate *time.Time `form:"recordedDate,omitempty" json:"recordedDate,omitempty" xml:"recordedDate,omitempty"`
	// Individual who recorded the record and takes responsibility for its conten.
	Recorder *Reference `form:"recorder,omitempty" json:"recorder,omitempty" xml:"recorder,omitempty"`
	// The source of the information about the allergy that is recorded.
	Reporter *Reference `form:"reporter,omitempty" json:"reporter,omitempty" xml:"reporter,omitempty"`
	// Assertion about certainty associated with a propensity, or potential risk, of a reaction to the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identification of the underlying physiological mechanism for the reaction risk. See http://hl7.org/fhir/ValueSet/allergy-intolerance-type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the AllergyIntolerance media type instance.
func (mt *AllergyIntolerance) Validate() (err error) {
	if mt.Category != nil {
		if !(*mt.Category == "food" || *mt.Category == "medication" || *mt.Category == "environment" || *mt.Category == "other") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.category`, *mt.Category, []interface{}{"food", "medication", "environment", "other"}))
		}
	}
	if mt.Criticality != nil {
		if !(*mt.Criticality == "CRITL" || *mt.Criticality == "CRITH" || *mt.Criticality == "CRITU") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.criticality`, *mt.Criticality, []interface{}{"CRITL", "CRITH", "CRITU"}))
		}
	}
	if mt.Reaction != nil {
		if err2 := mt.Reaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Status != nil {
		if !(*mt.Status == "active" || *mt.Status == "unconfirmed" || *mt.Status == "confirmed" || *mt.Status == "inactive" || *mt.Status == "resolved" || *mt.Status == "refuted" || *mt.Status == "entered-in-error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"active", "unconfirmed", "confirmed", "inactive", "resolved", "refuted", "entered-in-error"}))
		}
	}
	if mt.Type != nil {
		if !(*mt.Type == "allergy" || *mt.Type == "intolerance") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *mt.Type, []interface{}{"allergy", "intolerance"}))
		}
	}
	return
}

// DecodeAllergyIntolerance decodes the AllergyIntolerance instance encoded in resp body.
func (c *Client) DecodeAllergyIntolerance(resp *http.Response) (*AllergyIntolerance, error) {
	var decoded AllergyIntolerance
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Allergy_intoleranceCollection is the media type for an array of Allergy_intolerance (default view)
//
// Identifier: application/vnd.allergy_intolerance+json; type=collection; view=default
type AllergyIntoleranceCollection []*AllergyIntolerance

// Validate validates the AllergyIntoleranceCollection media type instance.
func (mt AllergyIntoleranceCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeAllergyIntoleranceCollection decodes the AllergyIntoleranceCollection instance encoded in resp body.
func (c *Client) DecodeAllergyIntoleranceCollection(resp *http.Response) (AllergyIntoleranceCollection, error) {
	var decoded AllergyIntoleranceCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Animal media type (default view)
//
// Identifier: application/vnd.animal+json; view=default
type Animal struct {
	Breed        *string `form:"breed,omitempty" json:"breed,omitempty" xml:"breed,omitempty"`
	GenderStatus *string `form:"genderStatus,omitempty" json:"genderStatus,omitempty" xml:"genderStatus,omitempty"`
	Species      *string `form:"species,omitempty" json:"species,omitempty" xml:"species,omitempty"`
}

// DecodeAnimal decodes the Animal instance encoded in resp body.
func (c *Client) DecodeAnimal(resp *http.Response) (*Animal, error) {
	var decoded Animal
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Annotation media type (default view)
//
// Identifier: application/vnd.annotation+json; view=default
type Annotation struct {
	// The individual responsible for making the annotation.
	AuthorReference *Reference `form:"authorReference,omitempty" json:"authorReference,omitempty" xml:"authorReference,omitempty"`
	// The individual responsible for making the annotation.
	AuthorString *string `form:"authorString,omitempty" json:"authorString,omitempty" xml:"authorString,omitempty"`
	// Indicates when this particular annotation was made.
	Time *time.Time `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
}

// DecodeAnnotation decodes the Annotation instance encoded in resp body.
func (c *Client) DecodeAnnotation(resp *http.Response) (*Annotation, error) {
	var decoded Annotation
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Attachment media type (default view)
//
// Identifier: application/vnd.attachment+json; view=default
type Attachment struct {
	// Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data.
	// 				Includes mime type parameters such as charset where appropriate. See http://www.rfc-editor.org/bcp/bcp13.txt
	ContentType *string `form:"contentType,omitempty" json:"contentType,omitempty" xml:"contentType,omitempty"`
	// The date that the attachment was first created.
	Creation *time.Time `form:"creation,omitempty" json:"creation,omitempty" xml:"creation,omitempty"`
	// The actual data of the attachment - a sequence of bytes. In XML, represented using base64.
	Data *string `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// The calculated hash of the data using SHA-1. Represented using base64.
	Hash *string `form:"hash,omitempty" json:"hash,omitempty" xml:"hash,omitempty"`
	// The number of bytes of data that make up this attachment.
	Size *int `form:"size,omitempty" json:"size,omitempty" xml:"size,omitempty"`
	// A label or set of text to display in place of the data.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// DecodeAttachment decodes the Attachment instance encoded in resp body.
func (c *Client) DecodeAttachment(resp *http.Response) (*Attachment, error) {
	var decoded Attachment
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// BackboneElement media type (default view)
//
// Identifier: application/vnd.backbone.element+json; view=default
type BackboneElement struct {
	Element           *Element   `form:"element,omitempty" json:"element,omitempty" xml:"element,omitempty"`
	ModifierExtension *Extension `form:"modifierExtension,omitempty" json:"modifierExtension,omitempty" xml:"modifierExtension,omitempty"`
}

// Validate validates the BackboneElement media type instance.
func (mt *BackboneElement) Validate() (err error) {
	if mt.Element != nil {
		if err2 := mt.Element.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ModifierExtension != nil {
		if err2 := mt.ModifierExtension.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeBackboneElement decodes the BackboneElement instance encoded in resp body.
func (c *Client) DecodeBackboneElement(resp *http.Response) (*BackboneElement, error) {
	var decoded BackboneElement
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// CodeableConcept media type (default view)
//
// Identifier: application/vnd.codeable.concept+json; view=default
type CodeableConcept struct {
	// A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
	Coding []*Coding `form:"coding,omitempty" json:"coding,omitempty" xml:"coding,omitempty"`
	// The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the
	// 	version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured. And when the meaning is not
	// 	guaranteed to be consistent, the version SHOULD be exchanged.
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
}

// DecodeCodeableConcept decodes the CodeableConcept instance encoded in resp body.
func (c *Client) DecodeCodeableConcept(resp *http.Response) (*CodeableConcept, error) {
	var decoded CodeableConcept
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Coding media type (default view)
//
// Identifier: application/vnd.coding+json; view=default
type Coding struct {
	// A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// A representation of the meaning of the code in the system, following the rules of the system.
	Display *string `form:"display,omitempty" json:"display,omitempty" xml:"display,omitempty"`
	// The identification of the code system that defines the meaning of the symbol in the code.Identity of the terminology system
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// Indicates that this coding was chosen by a user directly - i.e. off a pick list of available items (codes or displays).
	UserSelected *bool `form:"userSelected,omitempty" json:"userSelected,omitempty" xml:"userSelected,omitempty"`
	// The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the
	// 		version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured. And when the meaning is not
	// 		guaranteed to be consistent, the version SHOULD be exchanged.
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// DecodeCoding decodes the Coding instance encoded in resp body.
func (c *Client) DecodeCoding(resp *http.Response) (*Coding, error) {
	var decoded Coding
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Communication media type (default view)
//
// Identifier: application/vnd.communication+json; view=default
type Communication struct {
	CareProvider *string `form:"careProvider,omitempty" json:"careProvider,omitempty" xml:"careProvider,omitempty"`
	Language     *string `form:"language,omitempty" json:"language,omitempty" xml:"language,omitempty"`
	Preferred    *string `form:"preferred,omitempty" json:"preferred,omitempty" xml:"preferred,omitempty"`
}

// DecodeCommunication decodes the Communication instance encoded in resp body.
func (c *Client) DecodeCommunication(resp *http.Response) (*Communication, error) {
	var decoded Communication
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.
// 	Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations. (default view)
//
// Identifier: application/vnd.component+json; view=default
type Component struct {
	// Describes what was observed. Sometimes this is called the observation 'code'. See http://hl7.org/fhir/ValueSet/observation-codes
	Code *CodeableConcept `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Provides a reason why the expected value in the element Observation.value[x] is missing. See http://hl7.org/fhir/ValueSet/observation-valueabsentreason
	DataAbsentReason *CodeableConcept `form:"dataAbsentReason,omitempty" json:"dataAbsentReason,omitempty" xml:"dataAbsentReason,omitempty"`
	// Guidance on how to interpret the value by comparison to a normal or recommended range.
	ReferenceRange       *ReferenceRange  `form:"referenceRange,omitempty" json:"referenceRange,omitempty" xml:"referenceRange,omitempty"`
	ValueAttachment      *Attachment      `form:"valueAttachment,omitempty" json:"valueAttachment,omitempty" xml:"valueAttachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `form:"valueCodeableConcept,omitempty" json:"valueCodeableConcept,omitempty" xml:"valueCodeableConcept,omitempty"`
	ValueDatTime         *time.Time       `form:"valueDatTime,omitempty" json:"valueDatTime,omitempty" xml:"valueDatTime,omitempty"`
	ValuePeriod          *Period          `form:"valuePeriod,omitempty" json:"valuePeriod,omitempty" xml:"valuePeriod,omitempty"`
	ValueQuantity        *Quantity        `form:"valueQuantity,omitempty" json:"valueQuantity,omitempty" xml:"valueQuantity,omitempty"`
	ValueRange           *Range           `form:"valueRange,omitempty" json:"valueRange,omitempty" xml:"valueRange,omitempty"`
	ValueSampledData     *SampleData      `form:"valueSampledData,omitempty" json:"valueSampledData,omitempty" xml:"valueSampledData,omitempty"`
	ValueTime            *time.Time       `form:"valueTime,omitempty" json:"valueTime,omitempty" xml:"valueTime,omitempty"`
}

// Validate validates the Component media type instance.
func (mt *Component) Validate() (err error) {
	if mt.ReferenceRange != nil {
		if err2 := mt.ReferenceRange.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueQuantity != nil {
		if err2 := mt.ValueQuantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueRange != nil {
		if err2 := mt.ValueRange.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueSampledData != nil {
		if err2 := mt.ValueSampledData.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeComponent decodes the Component instance encoded in resp body.
func (c *Client) DecodeComponent(resp *http.Response) (*Component, error) {
	var decoded Component
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ComponentCollection is the media type for an array of Component (default view)
//
// Identifier: application/vnd.component+json; type=collection; view=default
type ComponentCollection []*Component

// Validate validates the ComponentCollection media type instance.
func (mt ComponentCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeComponentCollection decodes the ComponentCollection instance encoded in resp body.
func (c *Client) DecodeComponentCollection(resp *http.Response) (ComponentCollection, error) {
	var decoded ComponentCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Contact media type (default view)
//
// Identifier: application/vnd.contact+json; view=default
type Contact struct {
	Address      *string `form:"address,omitempty" json:"address,omitempty" xml:"address,omitempty"`
	Gender       *string `form:"gender,omitempty" json:"gender,omitempty" xml:"gender,omitempty"`
	Name         *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Organization *string `form:"organization,omitempty" json:"organization,omitempty" xml:"organization,omitempty"`
	Period       *string `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	Relationship *string `form:"relationship,omitempty" json:"relationship,omitempty" xml:"relationship,omitempty"`
	Telecom      *string `form:"telecom,omitempty" json:"telecom,omitempty" xml:"telecom,omitempty"`
}

// DecodeContact decodes the Contact instance encoded in resp body.
func (c *Client) DecodeContact(resp *http.Response) (*Contact, error) {
	var decoded Contact
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ContactPoint media type (default view)
//
// Identifier: application/vnd.contact.point+json; view=default
type ContactPoint struct {
	// Specifies a preferred order in which to use a set of contacts. Contacts are ranked with lower values coming before higher values.
	Rank *int `form:"rank,omitempty" json:"rank,omitempty" xml:"rank,omitempty"`
	// Telecommunications form for contact point - what communications system is required to make use of the contact.
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// Identifies the purpose for the contact point.
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
	// The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
	Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the ContactPoint media type instance.
func (mt *ContactPoint) Validate() (err error) {
	if mt.System != nil {
		if !(*mt.System == "phone" || *mt.System == "fax" || *mt.System == "email" || *mt.System == "pager" || *mt.System == "other") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.system`, *mt.System, []interface{}{"phone", "fax", "email", "pager", "other"}))
		}
	}
	if mt.Use != nil {
		if !(*mt.Use == "home" || *mt.Use == "work" || *mt.Use == "temp" || *mt.Use == "old" || *mt.Use == "mobile") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"home", "work", "temp", "old", "mobile"}))
		}
	}
	return
}

// DecodeContactPoint decodes the ContactPoint instance encoded in resp body.
func (c *Client) DecodeContactPoint(resp *http.Response) (*ContactPoint, error) {
	var decoded ContactPoint
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Element media type (default view)
//
// Identifier: application/vnd.element+json; view=default
type Element struct {
	Extension *Extension `form:"extension,omitempty" json:"extension,omitempty" xml:"extension,omitempty"`
	ID        *string    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Validate validates the Element media type instance.
func (mt *Element) Validate() (err error) {
	if mt.Extension != nil {
		if err2 := mt.Extension.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeElement decodes the Element instance encoded in resp body.
func (c *Client) DecodeElement(resp *http.Response) (*Element, error) {
	var decoded Element
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Enteral_formula media type (default view)
//
// Identifier: application/vnd.enteral_formula+json; view=default
type EnteralFormula struct {
	// Product or brand name of the enteral or infant formula
	AdditiveProductName *string `form:"additiveProductName,omitempty" json:"additiveProductName,omitempty" xml:"additiveProductName,omitempty"`
	// Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula.
	AdditiveType *CodeableConcept `form:"additiveType,omitempty" json:"additiveType,omitempty" xml:"additiveType,omitempty"`
	// Free text formula administration, feeding instructions or additional instructions or information.
	AdministrativeInstruction *string `form:"administrativeInstruction,omitempty" json:"administrativeInstruction,omitempty" xml:"administrativeInstruction,omitempty"`
	// The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula.
	BaseFormulaType *CodeableConcept `form:"baseFormulaType,omitempty" json:"baseFormulaType,omitempty" xml:"baseFormulaType,omitempty"`
	// Product or brand name of the enteral or infant formula
	BaseFormulatProdcutName *string `form:"baseFormulatProdcutName,omitempty" json:"baseFormulatProdcutName,omitempty" xml:"baseFormulatProdcutName,omitempty"`
	// The amount of energy (Calories) that the formula should provide per specified volume, typically per mL or fluid oz.
	// 	    For example, an infant may require a formula that provides 24 Calories per fluid ounce or an adult may require an enteral formula that provides 1.5 Calorie/mL.
	CaloricDensity *Quantity `form:"caloricDensity,omitempty" json:"caloricDensity,omitempty" xml:"caloricDensity,omitempty"`
	// The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours.
	MaxVolumeToDeliver *Quantity `form:"maxVolumeToDeliver,omitempty" json:"maxVolumeToDeliver,omitempty" xml:"maxVolumeToDeliver,omitempty"`
	// The route or physiological path of administration into the patient's gastrointestinal
	// 		tract for purposes of providing the formula feeding, e.g. nasogastric tube.
	RouteofAdministration *CodeableConcept `form:"routeofAdministration,omitempty" json:"routeofAdministration,omitempty" xml:"routeofAdministration,omitempty"`
}

// Validate validates the EnteralFormula media type instance.
func (mt *EnteralFormula) Validate() (err error) {
	if mt.CaloricDensity != nil {
		if err2 := mt.CaloricDensity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.MaxVolumeToDeliver != nil {
		if err2 := mt.MaxVolumeToDeliver.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeEnteralFormula decodes the EnteralFormula instance encoded in resp body.
func (c *Client) DecodeEnteralFormula(resp *http.Response) (*EnteralFormula, error) {
	var decoded EnteralFormula
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Enteral_formulaCollection is the media type for an array of Enteral_formula (default view)
//
// Identifier: application/vnd.enteral_formula+json; type=collection; view=default
type EnteralFormulaCollection []*EnteralFormula

// Validate validates the EnteralFormulaCollection media type instance.
func (mt EnteralFormulaCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeEnteralFormulaCollection decodes the EnteralFormulaCollection instance encoded in resp body.
func (c *Client) DecodeEnteralFormulaCollection(resp *http.Response) (EnteralFormulaCollection, error) {
	var decoded EnteralFormulaCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Default view for Extension element (default view)
//
// Identifier: application/vnd.extension+json; view=default
type Extension struct {
	ValueAddress         *Address         `form:"ValueAddress,omitempty" json:"ValueAddress,omitempty" xml:"ValueAddress,omitempty"`
	ValueAnnotation      *Annotation      `form:"ValueAnnotation,omitempty" json:"ValueAnnotation,omitempty" xml:"ValueAnnotation,omitempty"`
	ValueAttachment      *Attachment      `form:"ValueAttachment,omitempty" json:"ValueAttachment,omitempty" xml:"ValueAttachment,omitempty"`
	ValueBase64Binary    *string          `form:"ValueBase64Binary,omitempty" json:"ValueBase64Binary,omitempty" xml:"ValueBase64Binary,omitempty"`
	ValueBoolean         *bool            `form:"ValueBoolean,omitempty" json:"ValueBoolean,omitempty" xml:"ValueBoolean,omitempty"`
	ValueCode            *string          `form:"ValueCode,omitempty" json:"ValueCode,omitempty" xml:"ValueCode,omitempty"`
	ValueCodeableConcept *CodeableConcept `form:"ValueCodeableConcept,omitempty" json:"ValueCodeableConcept,omitempty" xml:"ValueCodeableConcept,omitempty"`
	ValueCoding          *Coding          `form:"ValueCoding,omitempty" json:"ValueCoding,omitempty" xml:"ValueCoding,omitempty"`
	ValueContactPoint    *string          `form:"ValueContactPoint,omitempty" json:"ValueContactPoint,omitempty" xml:"ValueContactPoint,omitempty"`
	ValueDate            *time.Time       `form:"ValueDate,omitempty" json:"ValueDate,omitempty" xml:"ValueDate,omitempty"`
	ValueDateTime        *time.Time       `form:"ValueDateTime,omitempty" json:"ValueDateTime,omitempty" xml:"ValueDateTime,omitempty"`
	ValueDecimal         *float64         `form:"ValueDecimal,omitempty" json:"ValueDecimal,omitempty" xml:"ValueDecimal,omitempty"`
	ValueHumanName       *HumanName       `form:"ValueHumanName,omitempty" json:"ValueHumanName,omitempty" xml:"ValueHumanName,omitempty"`
	ValueID              *string          `form:"ValueId,omitempty" json:"ValueId,omitempty" xml:"ValueId,omitempty"`
	ValueIdentifier      *Identifier      `form:"ValueIdentifier,omitempty" json:"ValueIdentifier,omitempty" xml:"ValueIdentifier,omitempty"`
	ValueInstant         *time.Time       `form:"ValueInstant,omitempty" json:"ValueInstant,omitempty" xml:"ValueInstant,omitempty"`
	ValueInteger         *int             `form:"ValueInteger,omitempty" json:"ValueInteger,omitempty" xml:"ValueInteger,omitempty"`
	ValueMarkdown        *string          `form:"ValueMarkdown,omitempty" json:"ValueMarkdown,omitempty" xml:"ValueMarkdown,omitempty"`
	ValueMeta            *Meta            `form:"ValueMeta,omitempty" json:"ValueMeta,omitempty" xml:"ValueMeta,omitempty"`
	ValueOid             *string          `form:"ValueOid,omitempty" json:"ValueOid,omitempty" xml:"ValueOid,omitempty"`
	ValuePeriod          *Period          `form:"ValuePeriod,omitempty" json:"ValuePeriod,omitempty" xml:"ValuePeriod,omitempty"`
	ValuePositiveInt     *float64         `form:"ValuePositiveInt,omitempty" json:"ValuePositiveInt,omitempty" xml:"ValuePositiveInt,omitempty"`
	ValueQuantity        *Quantity        `form:"ValueQuantity,omitempty" json:"ValueQuantity,omitempty" xml:"ValueQuantity,omitempty"`
	ValueRange           *string          `form:"ValueRange,omitempty" json:"ValueRange,omitempty" xml:"ValueRange,omitempty"`
	ValueRatio           *int             `form:"ValueRatio,omitempty" json:"ValueRatio,omitempty" xml:"ValueRatio,omitempty"`
	ValueReference       *Reference       `form:"ValueReference,omitempty" json:"ValueReference,omitempty" xml:"ValueReference,omitempty"`
	ValueSampledData     *string          `form:"ValueSampledData,omitempty" json:"ValueSampledData,omitempty" xml:"ValueSampledData,omitempty"`
	ValueSignature       *string          `form:"ValueSignature,omitempty" json:"ValueSignature,omitempty" xml:"ValueSignature,omitempty"`
	ValueString          *string          `form:"ValueString,omitempty" json:"ValueString,omitempty" xml:"ValueString,omitempty"`
	ValueTime            *time.Time       `form:"ValueTime,omitempty" json:"ValueTime,omitempty" xml:"ValueTime,omitempty"`
	ValueTiming          *time.Time       `form:"ValueTiming,omitempty" json:"ValueTiming,omitempty" xml:"ValueTiming,omitempty"`
	ValueUnsignedInt     *float64         `form:"ValueUnsignedInt,omitempty" json:"ValueUnsignedInt,omitempty" xml:"ValueUnsignedInt,omitempty"`
	ValueURI             *string          `form:"ValueUri,omitempty" json:"ValueUri,omitempty" xml:"ValueUri,omitempty"`
	URL                  *string          `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// Validate validates the Extension media type instance.
func (mt *Extension) Validate() (err error) {
	if mt.ValueAddress != nil {
		if err2 := mt.ValueAddress.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueHumanName != nil {
		if err2 := mt.ValueHumanName.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueMeta != nil {
		if err2 := mt.ValueMeta.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueQuantity != nil {
		if err2 := mt.ValueQuantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeExtension decodes the Extension instance encoded in resp body.
func (c *Client) DecodeExtension(resp *http.Response) (*Extension, error) {
	var decoded Extension
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeErrorResponse decodes the ErrorResponse instance encoded in resp body.
func (c *Client) DecodeErrorResponse(resp *http.Response) (*goa.ErrorResponse, error) {
	var decoded goa.ErrorResponse
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OAuth2 error response, see https://tools.ietf.org/html/rfc6749#section-5.2 (default view)
//
// Identifier: application/vnd.goa.example.oauth2.error+json; view=default
type OAuth2ErrorMedia struct {
	// Error returned by authorization server
	Error string `form:"error" json:"error" xml:"error"`
	// Human readable ASCII text providing additional information
	ErrorDescription *string `form:"error_description,omitempty" json:"error_description,omitempty" xml:"error_description,omitempty"`
	// A URI identifying a human-readable web page with information about the error
	ErrorURI *string `form:"error_uri,omitempty" json:"error_uri,omitempty" xml:"error_uri,omitempty"`
}

// Validate validates the OAuth2ErrorMedia media type instance.
func (mt *OAuth2ErrorMedia) Validate() (err error) {
	if mt.Error == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "error"))
	}
	if !(mt.Error == "invalid_request" || mt.Error == "invalid_client" || mt.Error == "invalid_grant" || mt.Error == "unauthorized_client" || mt.Error == "unsupported_grant_type") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.error`, mt.Error, []interface{}{"invalid_request", "invalid_client", "invalid_grant", "unauthorized_client", "unsupported_grant_type"}))
	}
	return
}

// DecodeOAuth2ErrorMedia decodes the OAuth2ErrorMedia instance encoded in resp body.
func (c *Client) DecodeOAuth2ErrorMedia(resp *http.Response) (*OAuth2ErrorMedia, error) {
	var decoded OAuth2ErrorMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OAuth2 access token request successful response, see https://tools.ietf.org/html/rfc6749#section-5.1 (default view)
//
// Identifier: application/vnd.goa.example.oauth2.token+json; view=default
type TokenMedia struct {
	// The access token issued by the authorization server
	AccessToken string `form:"access_token" json:"access_token" xml:"access_token"`
	// The lifetime in seconds of the access token
	ExpiresIn *int `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// The refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// The scope of the access token
	Scope *string `form:"scope,omitempty" json:"scope,omitempty" xml:"scope,omitempty"`
	// The type of the token issued, e.g. "bearer" or "mac"
	TokenType string `form:"token_type" json:"token_type" xml:"token_type"`
}

// Validate validates the TokenMedia media type instance.
func (mt *TokenMedia) Validate() (err error) {
	if mt.AccessToken == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "access_token"))
	}
	if mt.TokenType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "token_type"))
	}
	return
}

// DecodeTokenMedia decodes the TokenMedia instance encoded in resp body.
func (c *Client) DecodeTokenMedia(resp *http.Response) (*TokenMedia, error) {
	var decoded TokenMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OAuth2 error response, See https://tools.ietf.org/html/rfc6749#section-5.2 (default view)
//
// Identifier: application/vnd.goa.fhir.oauth2.error+json; view=default
type OAuth2ErrorMedia struct {
	// Error returned by authorization server
	Error string `form:"error" json:"error" xml:"error"`
	// Human readable ASCII text providing additional information
	ErrorDescription *string `form:"error_description,omitempty" json:"error_description,omitempty" xml:"error_description,omitempty"`
	// A URI identifying a human-readable web page with information about the error
	ErrorURI *string `form:"error_uri,omitempty" json:"error_uri,omitempty" xml:"error_uri,omitempty"`
}

// Validate validates the OAuth2ErrorMedia media type instance.
func (mt *OAuth2ErrorMedia) Validate() (err error) {
	if mt.Error == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "error"))
	}
	if !(mt.Error == "invalid_request" || mt.Error == "invalid_client" || mt.Error == "invalid_grant" || mt.Error == "unauthorized_client" || mt.Error == "unsupported_grant_type") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.error`, mt.Error, []interface{}{"invalid_request", "invalid_client", "invalid_grant", "unauthorized_client", "unsupported_grant_type"}))
	}
	return
}

// DecodeOAuth2ErrorMedia decodes the OAuth2ErrorMedia instance encoded in resp body.
func (c *Client) DecodeOAuth2ErrorMedia(resp *http.Response) (*OAuth2ErrorMedia, error) {
	var decoded OAuth2ErrorMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// OAuth2 access token request successful response, See https://tools.ietf.org/html/rfc6749#section-5.1 (default view)
//
// Identifier: application/vnd.goa.fhir.oauth2.token+json; view=default
type TokenMedia struct {
	// The access token issued by the authorization server
	AccessToken string `form:"access_token" json:"access_token" xml:"access_token"`
	// The lifetime in seconds of the access token
	ExpiresIn *int `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// The refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// The scope of the access token
	Scope *string `form:"scope,omitempty" json:"scope,omitempty" xml:"scope,omitempty"`
	// The type of the token issued, e.g. "bearer" or "mac"
	TokenType string `form:"token_type" json:"token_type" xml:"token_type"`
}

// Validate validates the TokenMedia media type instance.
func (mt *TokenMedia) Validate() (err error) {
	if mt.AccessToken == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "access_token"))
	}
	if mt.TokenType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "token_type"))
	}
	return
}

// DecodeTokenMedia decodes the TokenMedia instance encoded in resp body.
func (c *Client) DecodeTokenMedia(resp *http.Response) (*TokenMedia, error) {
	var decoded TokenMedia
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// The common media type to all request responses for this example (default view)
//
// Identifier: application/vnd.goa.fhir.security.success; view=default
type Success struct {
	// Always true
	OK bool `form:"ok" json:"ok" xml:"ok"`
}

// DecodeSuccess decodes the Success instance encoded in resp body.
func (c *Client) DecodeSuccess(resp *http.Response) (*Success, error) {
	var decoded Success
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// HumanName media type (default view)
//
// Identifier: application/vnd.human.name+json; view=default
type HumanName struct {
	// The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
	Family []string `form:"family,omitempty" json:"family,omitempty" xml:"family,omitempty"`
	// Given names (not always 'first'). Includes middle names
	Given *string `form:"given,omitempty" json:"given,omitempty" xml:"given,omitempty"`
	// Indicates the period of time when this name was valid for the named person.
	Period *Period `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty" xml:"prefix,omitempty"`
	// Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
	Suffix *string `form:"suffix,omitempty" json:"suffix,omitempty" xml:"suffix,omitempty"`
	// Identifies the purpose for this name.
	Use *string `form:"use,omitempty" json:"use,omitempty" xml:"use,omitempty"`
}

// Validate validates the HumanName media type instance.
func (mt *HumanName) Validate() (err error) {
	if mt.Use != nil {
		if !(*mt.Use == "usual" || *mt.Use == "official" || *mt.Use == "temp" || *mt.Use == "nickname" || *mt.Use == "anonymous" || *mt.Use == "old" || *mt.Use == "maiden") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.use`, *mt.Use, []interface{}{"usual", "official", "temp", "nickname", "anonymous", "old", "maiden"}))
		}
	}
	return
}

// DecodeHumanName decodes the HumanName instance encoded in resp body.
func (c *Client) DecodeHumanName(resp *http.Response) (*HumanName, error) {
	var decoded HumanName
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Identifier media type (default view)
//
// Identifier: application/vnd.identifier+json; view=default
type Identifier struct {
	// A coded type for the identifier that can be used to determine which identifier to use for a specific purpose.
	CodeableConcept *CodeableConcept `form:"CodeableConcept,omitempty" json:"CodeableConcept,omitempty" xml:"CodeableConcept,omitempty"`
	// Organization that issued/manages the identifier.
	Assigner *Reference `form:"assigner,omitempty" json:"assigner,omitempty" xml:"assigner,omitempty"`
	// Time period during which identifier is/was valid for use.
	Period *Period `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
}

// DecodeIdentifier decodes the Identifier instance encoded in resp body.
func (c *Client) DecodeIdentifier(resp *http.Response) (*Identifier, error) {
	var decoded Identifier
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Link media type (default view)
//
// Identifier: application/vnd.link+json; view=default
type Link struct {
	Other *string `form:"other,omitempty" json:"other,omitempty" xml:"other,omitempty"`
	Type  *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// DecodeLink decodes the Link instance encoded in resp body.
func (c *Client) DecodeLink(resp *http.Response) (*Link, error) {
	var decoded Link
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Meta media type (default view)
//
// Identifier: application/vnd.meta+json; view=default
type Meta struct {
	// When the resource last changed - e.g. when the version changed.
	LastUpdated *time.Time `form:"lastUpdated,omitempty" json:"lastUpdated,omitempty" xml:"lastUpdated,omitempty"`
	// A list of profiles [[[StructureDefinition]]]s that this resource claims to conform to. The URL is a reference to [[[StructureDefinition.url]]].
	Profile *string `form:"profile,omitempty" json:"profile,omitempty" xml:"profile,omitempty"`
	// Security labels applied to this resource. These tags connect specific resources to the overall security policy and infrastructure.
	Security *Coding `form:"security,omitempty" json:"security,omitempty" xml:"security,omitempty"`
	// Tags applied to this resource. Tags are intended to be used to identify and relate resources to process and workflow, and applications are not required to consider the tags when interpreting the meaning of a resource.
	Tag *Coding `form:"tag,omitempty" json:"tag,omitempty" xml:"tag,omitempty"`
	// The version specific identifier, as it appears in the version portion of the URL. This values changes when the resource is created, updated, or deleted.
	VersionID *string `form:"versionId,omitempty" json:"versionId,omitempty" xml:"versionId,omitempty"`
}

// Validate validates the Meta media type instance.
func (mt *Meta) Validate() (err error) {
	if mt.Profile != nil {
		if err2 := goa.ValidateFormat(goa.FormatURI, *mt.Profile); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.profile`, *mt.Profile, goa.FormatURI, err2))
		}
	}
	return
}

// DecodeMeta decodes the Meta instance encoded in resp body.
func (c *Client) DecodeMeta(resp *http.Response) (*Meta, error) {
	var decoded Meta
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Nutrient media type (default view)
//
// Identifier: application/vnd.nutrient+json; view=default
type Nutrient struct {
	// The quantity of the specified nutrient to include in diet.
	Amount *Quantity `form:"amount,omitempty" json:"amount,omitempty" xml:"amount,omitempty"`
	// The nutrient that is being modified such as carbohydrate or sodium. See http://hl7.org/fhir/ValueSet/nutrient-code
	Modifier *CodeableConcept `form:"modifier,omitempty" json:"modifier,omitempty" xml:"modifier,omitempty"`
}

// Validate validates the Nutrient media type instance.
func (mt *Nutrient) Validate() (err error) {
	if mt.Amount != nil {
		if err2 := mt.Amount.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeNutrient decodes the Nutrient instance encoded in resp body.
func (c *Client) DecodeNutrient(resp *http.Response) (*Nutrient, error) {
	var decoded Nutrient
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Nutrition_request media type (default view)
//
// Identifier: application/vnd.nutrition_request+json; view=default
type NutritionRequest struct {
	// A link to a record of allergies or intolerances  which should be included in the nutrition order.
	AllergyIntolerance []*Reference `form:"allergyIntolerance,omitempty" json:"allergyIntolerance,omitempty" xml:"allergyIntolerance,omitempty"`
	// The date and time that this nutrition order was requested.
	DateTime *time.Time `form:"dateTime,omitempty" json:"dateTime,omitempty" xml:"dateTime,omitempty"`
	// An encounter that provides additional information about the healthcare context in which this request is made.
	Encounter *Reference `form:"encounter,omitempty" json:"encounter,omitempty" xml:"encounter,omitempty"`
	// Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
	EnteralFormula EnteralFormulaCollection `form:"enteralFormula,omitempty" json:"enteralFormula,omitempty" xml:"enteralFormula,omitempty"`
	// This modifier is used to convey order-specific modifiers about the type of food that should NOT be given. These can be derived from
	// 		patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance
	// 		information captured in the referenced allergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be
	// 		eliminated from the patientâ€™s diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
	// 		See http://hl7.org/fhir/ValueSet/food-type
	ExcludeFoodModifier []*CodeableConcept `form:"excludeFoodModifier,omitempty" json:"excludeFoodModifier,omitempty" xml:"excludeFoodModifier,omitempty"`
	// This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived
	// 		from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional
	// 		supplements and enteral formula feedings. See http://hl7.org/fhir/ValueSet/encounter-diet
	FoodPreferenceModifier []*CodeableConcept `form:"foodPreferenceModifier,omitempty" json:"foodPreferenceModifier,omitempty" xml:"foodPreferenceModifier,omitempty"`
	// Identifiers assigned to this order by the order sender or by the order receiver.
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// Diet given orally in contrast to enteral (tube) feeding.
	OralDiet OralDietCollection `form:"oralDiet,omitempty" json:"oralDiet,omitempty" xml:"oralDiet,omitempty"`
	// The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
	Orderer *Reference `form:"orderer,omitempty" json:"orderer,omitempty" xml:"orderer,omitempty"`
	// The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
	Patient *Reference `form:"patient,omitempty" json:"patient,omitempty" xml:"patient,omitempty"`
	// The workflow status of the nutrition order/request. See http://hl7.org/fhir/nutrition-request-status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Oral nutritional products given in order to add further nutritional value to the patient's diet.
	Supplement []*Supplement `form:"supplement,omitempty" json:"supplement,omitempty" xml:"supplement,omitempty"`
}

// Validate validates the NutritionRequest media type instance.
func (mt *NutritionRequest) Validate() (err error) {
	if err2 := mt.EnteralFormula.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	if err2 := mt.OralDiet.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	if mt.Status != nil {
		if !(*mt.Status == "proposed" || *mt.Status == "draft" || *mt.Status == "planned" || *mt.Status == "requested" || *mt.Status == "active" || *mt.Status == "on-hold" || *mt.Status == "completed" || *mt.Status == "cancelled") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"proposed", "draft", "planned", "requested", "active", "on-hold", "completed", "cancelled"}))
		}
	}
	for _, e := range mt.Supplement {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeNutritionRequest decodes the NutritionRequest instance encoded in resp body.
func (c *Client) DecodeNutritionRequest(resp *http.Response) (*NutritionRequest, error) {
	var decoded NutritionRequest
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Nutrition_requestCollection is the media type for an array of Nutrition_request (default view)
//
// Identifier: application/vnd.nutrition_request+json; type=collection; view=default
type NutritionRequestCollection []*NutritionRequest

// Validate validates the NutritionRequestCollection media type instance.
func (mt NutritionRequestCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeNutritionRequestCollection decodes the NutritionRequestCollection instance encoded in resp body.
func (c *Client) DecodeNutritionRequestCollection(resp *http.Response) (NutritionRequestCollection, error) {
	var decoded NutritionRequestCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Demographics and other administrative information about an individual or animal receiving care or other health-related services. (default view)
//
// Identifier: application/vnd.observation+json; view=default
type Observation struct {
	// Indicates the site on the subject's body where the observation was made (i.e. the target site). See http://hl7.org/fhir/ValueSet/body-site
	BodySite *CodeableConcept `form:"bodySite,omitempty" json:"bodySite,omitempty" xml:"bodySite,omitempty"`
	// A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes. See http://hl7.org/fhir/ValueSet/observation-category
	Category *CodeableConcept `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// Describes what was observed. Sometimes this is called the observation 'name'. See http://hl7.org/fhir/ValueSet/observation-codes
	Code *CodeableConcept `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
	Comments *string `form:"comments,omitempty" json:"comments,omitempty" xml:"comments,omitempty"`
	// Some observations have multiple component observations.  These component observations are expressed as separate code
	// 		value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple
	// 		component observations for genetics observations.
	Component ComponentCollection `form:"component,omitempty" json:"component,omitempty" xml:"component,omitempty"`
	// Provides a reason why the expected value in the element Observation.value[x] is missing. See http://hl7.org/fhir/ValueSet/observation-valueabsentreason
	DateAbsentReason *CodeableConcept `form:"dateAbsentReason,omitempty" json:"dateAbsentReason,omitempty" xml:"dateAbsentReason,omitempty"`
	// The device used to generate the observation data.
	Device *Reference `form:"device,omitempty" json:"device,omitempty" xml:"device,omitempty"`
	// The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients -
	// 		this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection,
	// 		but very often the source of the date/time is not known, only the date/time itself.
	EffectiveDateTime *time.Time `form:"effectiveDateTime,omitempty" json:"effectiveDateTime,omitempty" xml:"effectiveDateTime,omitempty"`
	// The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients -
	// 		this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection,
	// 		but very often the source of the date/time is not known, only the date/time itself.
	EffectivePeriod *Period `form:"effectivePeriod,omitempty" json:"effectivePeriod,omitempty" xml:"effectivePeriod,omitempty"`
	// The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made.
	Encounter *Reference `form:"encounter,omitempty" json:"encounter,omitempty" xml:"encounter,omitempty"`
	// A unique identifier for the simple observation instance.
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// The assessment made based on the result of the observation.  Intended as a simple compact code often
	// 		placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag.
	// 		See http://hl7.org/fhir/ValueSet/observation-interpretation
	Interpretation *CodeableConcept `form:"interpretation,omitempty" json:"interpretation,omitempty" xml:"interpretation,omitempty"`
	// The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
	Issued *time.Time `form:"issued,omitempty" json:"issued,omitempty" xml:"issued,omitempty"`
	// Indicates the mechanism used to perform the observation. See http://hl7.org/fhir/ValueSet/observation-methods
	Method *CodeableConcept `form:"method,omitempty" json:"method,omitempty" xml:"method,omitempty"`
	// Who was responsible for asserting the observed value as 'true'.
	Performer []*Reference `form:"performer,omitempty" json:"performer,omitempty" xml:"performer,omitempty"`
	// Guidance on how to interpret the value by comparison to a normal or recommended range.
	ReferenceRange ReferenceRangeCollection `form:"referenceRange,omitempty" json:"referenceRange,omitempty" xml:"referenceRange,omitempty"`
	// A  reference to another resource (usually another Observation but could  also be a QuestionnaireAnswer) whose relationship is defined by the relationship type code.
	Related RelatedCollection `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	// The specimen that was used when this observation was made.
	Specimen *Reference `form:"specimen,omitempty" json:"specimen,omitempty" xml:"specimen,omitempty"`
	// The status of the result value. See http://hl7.org/fhir/ValueSet/observation-status
	Status               *string          `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	ValueAttachment      *Attachment      `form:"valueAttachment,omitempty" json:"valueAttachment,omitempty" xml:"valueAttachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `form:"valueCodeableConcept,omitempty" json:"valueCodeableConcept,omitempty" xml:"valueCodeableConcept,omitempty"`
	ValueDatTime         *time.Time       `form:"valueDatTime,omitempty" json:"valueDatTime,omitempty" xml:"valueDatTime,omitempty"`
	ValuePeriod          *Period          `form:"valuePeriod,omitempty" json:"valuePeriod,omitempty" xml:"valuePeriod,omitempty"`
	ValueQuantity        *Quantity        `form:"valueQuantity,omitempty" json:"valueQuantity,omitempty" xml:"valueQuantity,omitempty"`
	ValueRange           *Range           `form:"valueRange,omitempty" json:"valueRange,omitempty" xml:"valueRange,omitempty"`
	ValueSampledData     *SampleData      `form:"valueSampledData,omitempty" json:"valueSampledData,omitempty" xml:"valueSampledData,omitempty"`
	ValueString          *string          `form:"valueString,omitempty" json:"valueString,omitempty" xml:"valueString,omitempty"`
	ValueTime            *time.Time       `form:"valueTime,omitempty" json:"valueTime,omitempty" xml:"valueTime,omitempty"`
}

// Validate validates the Observation media type instance.
func (mt *Observation) Validate() (err error) {
	if err2 := mt.Component.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	if err2 := mt.ReferenceRange.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	if mt.Status != nil {
		if !(*mt.Status == "registered" || *mt.Status == "preliminary" || *mt.Status == "final" || *mt.Status == "amended +") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"registered", "preliminary", "final", "amended +"}))
		}
	}
	if mt.ValueQuantity != nil {
		if err2 := mt.ValueQuantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueRange != nil {
		if err2 := mt.ValueRange.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.ValueSampledData != nil {
		if err2 := mt.ValueSampledData.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeObservation decodes the Observation instance encoded in resp body.
func (c *Client) DecodeObservation(resp *http.Response) (*Observation, error) {
	var decoded Observation
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Oral_diet media type (default view)
//
// Identifier: application/vnd.oral_diet+json; view=default
type OralDiet struct {
	// The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient. See http://hl7.org/fhir/ValueSet/consistency-type
	FluidConsistencyType *CodeableConcept `form:"fluidConsistencyType,omitempty" json:"fluidConsistencyType,omitempty" xml:"fluidConsistencyType,omitempty"`
	// Free text or additional instructions or information pertaining to the oral diet.
	Instruction *string `form:"instruction,omitempty" json:"instruction,omitempty" xml:"instruction,omitempty"`
	// Class that defines the quantity and type of nutrient modifications required for the oral diet.
	Nutrient *Nutrient `form:"nutrient,omitempty" json:"nutrient,omitempty" xml:"nutrient,omitempty"`
	// The time period and frequency at which the diet should be given.
	Schedule *Timing `form:"schedule,omitempty" json:"schedule,omitempty" xml:"schedule,omitempty"`
	// Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
	Texture *Texture `form:"texture,omitempty" json:"texture,omitempty" xml:"texture,omitempty"`
	// The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet. See http://hl7.org/fhir/ValueSet/diet-type
	Type *CodeableConcept `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the OralDiet media type instance.
func (mt *OralDiet) Validate() (err error) {
	if mt.Nutrient != nil {
		if err2 := mt.Nutrient.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Schedule != nil {
		if err2 := mt.Schedule.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeOralDiet decodes the OralDiet instance encoded in resp body.
func (c *Client) DecodeOralDiet(resp *http.Response) (*OralDiet, error) {
	var decoded OralDiet
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Oral_dietCollection is the media type for an array of Oral_diet (default view)
//
// Identifier: application/vnd.oral_diet+json; type=collection; view=default
type OralDietCollection []*OralDiet

// Validate validates the OralDietCollection media type instance.
func (mt OralDietCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeOralDietCollection decodes the OralDietCollection instance encoded in resp body.
func (c *Client) DecodeOralDietCollection(resp *http.Response) (OralDietCollection, error) {
	var decoded OralDietCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Patient media type (default view)
//
// Identifier: application/vnd.patient+json; view=default
type Patient struct {
	Active               *string `form:"active,omitempty" json:"active,omitempty" xml:"active,omitempty"`
	Address              *string `form:"address,omitempty" json:"address,omitempty" xml:"address,omitempty"`
	Animal               *string `form:"animal,omitempty" json:"animal,omitempty" xml:"animal,omitempty"`
	BirthDate            *string `form:"birthDate,omitempty" json:"birthDate,omitempty" xml:"birthDate,omitempty"`
	CareProvider         *string `form:"careProvider,omitempty" json:"careProvider,omitempty" xml:"careProvider,omitempty"`
	Communication        *string `form:"communication,omitempty" json:"communication,omitempty" xml:"communication,omitempty"`
	Contact              *string `form:"contact,omitempty" json:"contact,omitempty" xml:"contact,omitempty"`
	CreatedAt            *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	CreatedBy            *string `form:"created_by,omitempty" json:"created_by,omitempty" xml:"created_by,omitempty"`
	DeceasedBoolean      *string `form:"deceasedBoolean,omitempty" json:"deceasedBoolean,omitempty" xml:"deceasedBoolean,omitempty"`
	DeceasedDateTime     *string `form:"deceasedDateTime,omitempty" json:"deceasedDateTime,omitempty" xml:"deceasedDateTime,omitempty"`
	Gender               string  `form:"gender" json:"gender" xml:"gender"`
	Href                 *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	ID                   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Identifier           *string `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	Link                 *string `form:"link,omitempty" json:"link,omitempty" xml:"link,omitempty"`
	ManagingOrganization *string `form:"managingOrganization,omitempty" json:"managingOrganization,omitempty" xml:"managingOrganization,omitempty"`
	MultipleBirthBoolean *string `form:"multipleBirthBoolean,omitempty" json:"multipleBirthBoolean,omitempty" xml:"multipleBirthBoolean,omitempty"`
	MultipleBirthInteger *string `form:"multipleBirthInteger,omitempty" json:"multipleBirthInteger,omitempty" xml:"multipleBirthInteger,omitempty"`
	Name                 *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Photo                *string `form:"photo,omitempty" json:"photo,omitempty" xml:"photo,omitempty"`
}

// Validate validates the Patient media type instance.
func (mt *Patient) Validate() (err error) {
	if mt.Gender == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "gender"))
	}
	return
}

// Patient media type (link view)
//
// Identifier: application/vnd.patient+json; view=link
type PatientLink struct {
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	ID   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DecodePatient decodes the Patient instance encoded in resp body.
func (c *Client) DecodePatient(resp *http.Response) (*Patient, error) {
	var decoded Patient
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodePatientLink decodes the PatientLink instance encoded in resp body.
func (c *Client) DecodePatientLink(resp *http.Response) (*PatientLink, error) {
	var decoded PatientLink
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// PatientCollection is the media type for an array of Patient (default view)
//
// Identifier: application/vnd.patient+json; type=collection; view=default
type PatientCollection []*Patient

// Validate validates the PatientCollection media type instance.
func (mt PatientCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// PatientCollection is the media type for an array of Patient (link view)
//
// Identifier: application/vnd.patient+json; type=collection; view=link
type PatientLinkCollection []*PatientLink

// DecodePatientCollection decodes the PatientCollection instance encoded in resp body.
func (c *Client) DecodePatientCollection(resp *http.Response) (PatientCollection, error) {
	var decoded PatientCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodePatientLinkCollection decodes the PatientLinkCollection instance encoded in resp body.
func (c *Client) DecodePatientLinkCollection(resp *http.Response) (PatientLinkCollection, error) {
	var decoded PatientLinkCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// A time period defined by a start and end date and optionally time. (default view)
//
// Identifier: application/vnd.period+json; view=default
type Period struct {
	// End time with inclusive boundary, if not ongoing
	End *time.Time `form:"end,omitempty" json:"end,omitempty" xml:"end,omitempty"`
	// Starting time with inclusive boundary
	Start *time.Time `form:"start,omitempty" json:"start,omitempty" xml:"start,omitempty"`
}

// DecodePeriod decodes the Period instance encoded in resp body.
func (c *Client) DecodePeriod(resp *http.Response) (*Period, error) {
	var decoded Period
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Quantity media type (default view)
//
// Identifier: application/vnd.quantity+json; view=default
type Quantity struct {
	// A computer processable form of the unit in some unit representation system.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues;
	// 		e.g. if the comparator is "<" , then the real value is < stated value. See http://hl7.org/fhir/ValueSet/quantity-comparator
	Comparator *string `form:"comparator,omitempty" json:"comparator,omitempty" xml:"comparator,omitempty"`
	// The identification of the system that provides the coded form of the unit.
	System *string `form:"system,omitempty" json:"system,omitempty" xml:"system,omitempty"`
	// A human-readable form of the unit.
	Unit *string `form:"unit,omitempty" json:"unit,omitempty" xml:"unit,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the Quantity media type instance.
func (mt *Quantity) Validate() (err error) {
	if mt.Comparator != nil {
		if !(*mt.Comparator == "<" || *mt.Comparator == "<=" || *mt.Comparator == ">=" || *mt.Comparator == ">") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.comparator`, *mt.Comparator, []interface{}{"<", "<=", ">=", ">"}))
		}
	}
	if mt.System != nil {
		if err2 := goa.ValidateFormat(goa.FormatURI, *mt.System); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`response.system`, *mt.System, goa.FormatURI, err2))
		}
	}
	return
}

// DecodeQuantity decodes the Quantity instance encoded in resp body.
func (c *Client) DecodeQuantity(resp *http.Response) (*Quantity, error) {
	var decoded Quantity
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Range media type (default view)
//
// Identifier: application/vnd.range+json; view=default
type Range struct {
	// The high limit. The boundary is inclusive.
	High *Quantity `form:"high,omitempty" json:"high,omitempty" xml:"high,omitempty"`
	// The low limit. The boundary is inclusive.
	Low *Quantity `form:"low,omitempty" json:"low,omitempty" xml:"low,omitempty"`
}

// Validate validates the Range media type instance.
func (mt *Range) Validate() (err error) {
	if mt.High != nil {
		if err2 := mt.High.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Low != nil {
		if err2 := mt.Low.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeRange decodes the Range instance encoded in resp body.
func (c *Client) DecodeRange(resp *http.Response) (*Range, error) {
	var decoded Range
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Ratio media type (default view)
//
// Identifier: application/vnd.ratio+json; view=default
type Ratio struct {
	// The value of the denominator.
	Denominator *Quantity `form:"denominator,omitempty" json:"denominator,omitempty" xml:"denominator,omitempty"`
	// The value of the numerator.
	Numerator *Quantity `form:"numerator,omitempty" json:"numerator,omitempty" xml:"numerator,omitempty"`
}

// Validate validates the Ratio media type instance.
func (mt *Ratio) Validate() (err error) {
	if mt.Denominator != nil {
		if err2 := mt.Denominator.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Numerator != nil {
		if err2 := mt.Numerator.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeRatio decodes the Ratio instance encoded in resp body.
func (c *Client) DecodeRatio(resp *http.Response) (*Ratio, error) {
	var decoded Ratio
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Reaction media type (default view)
//
// Identifier: application/vnd.reaction+json; view=default
type Reaction struct {
	// Statement about the degree of clinical certainty that the specific substance was the cause of the manifestation in this reaction event. See http://hl7.org/fhir/ValueSet/reaction-event-certainty
	Certainty *string `form:"certainty,omitempty" json:"certainty,omitempty" xml:"certainty,omitempty"`
	// Text description about the reaction as a whole, including details of the manifestation if required.
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Identification of the route by which the subject was exposed to the substance. See http://hl7.org/fhir/ValueSet/route-codes
	ExposureRoute *CodeableConcept `form:"exposureRoute,omitempty" json:"exposureRoute,omitempty" xml:"exposureRoute,omitempty"`
	// Clinical symptoms and/or signs that are observed or associated with the adverse reaction event. See http://hl7.org/fhir/ValueSet/manifestation-codes
	Manifestation *CodeableConcept `form:"manifestation,omitempty" json:"manifestation,omitempty" xml:"manifestation,omitempty"`
	// Additional text about the adverse reaction event not captured in other fields.
	Note *Annotation `form:"note,omitempty" json:"note,omitempty" xml:"note,omitempty"`
	// Record of the date and/or time of the onset of the Reaction.
	Onset *time.Time `form:"onset,omitempty" json:"onset,omitempty" xml:"onset,omitempty"`
	// Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations. See http://hl7.org/fhir/ValueSet/reaction-event-severity
	Severity *string `form:"severity,omitempty" json:"severity,omitempty" xml:"severity,omitempty"`
	// Identification of the specific substance considered to be responsible for the Adverse Reaction event.
	// 		Note: the substance for a specific reaction may be different to the substance identified as the cause of the risk, but must be consistent with it.
	// 		For instance, it may be a more specific substance (e.g. a brand medication) or a composite substance that includes the identified substance.
	// 		It must be clinically safe to only process the AllergyIntolerance.substance and ignore the AllergyIntolerance.event.substance.
	Substance *CodeableConcept `form:"substance,omitempty" json:"substance,omitempty" xml:"substance,omitempty"`
}

// Validate validates the Reaction media type instance.
func (mt *Reaction) Validate() (err error) {
	if mt.Certainty != nil {
		if !(*mt.Certainty == "unlikely" || *mt.Certainty == "likely" || *mt.Certainty == "confirmed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.certainty`, *mt.Certainty, []interface{}{"unlikely", "likely", "confirmed"}))
		}
	}
	if mt.Severity != nil {
		if !(*mt.Severity == "mild" || *mt.Severity == "moderate" || *mt.Severity == "severe") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.severity`, *mt.Severity, []interface{}{"mild", "moderate", "severe"}))
		}
	}
	return
}

// DecodeReaction decodes the Reaction instance encoded in resp body.
func (c *Client) DecodeReaction(resp *http.Response) (*Reaction, error) {
	var decoded Reaction
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Reference media type (default view)
//
// Identifier: application/vnd.reference+json; view=default
type Reference struct {
	// Plain text narrative that identifies the resource in addition to the resource reference.
	Display *string `form:"display,omitempty" json:"display,omitempty" xml:"display,omitempty"`
	// A reference to a location at which the other resource is found. The reference may be a relative reference, in which case it is relative to
	// 		the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is
	// 		not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with '#') refer to contained resources.
	Reference *string `form:"reference,omitempty" json:"reference,omitempty" xml:"reference,omitempty"`
}

// DecodeReference decodes the Reference instance encoded in resp body.
func (c *Client) DecodeReference(resp *http.Response) (*Reference, error) {
	var decoded Reference
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Details concerning the observation collection. (default view)
//
// Identifier: application/vnd.reference.range+json; view=default
type ReferenceRange struct {
	// Time when observation was collected from subject - the physiologically relevant time.
	Age *Range `form:"age,omitempty" json:"age,omitempty" xml:"age,omitempty"`
	// The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value
	// 		(e.g.  reference range is >=5 - <=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3).
	High *Quantity `form:"high,omitempty" json:"high,omitempty" xml:"high,omitempty"`
	// The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value
	// 		(e.g.  reference range is >=5 - <=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3).
	Low *Quantity `form:"low,omitempty" json:"low,omitempty" xml:"low,omitempty"`
	// Code for the meaning of the reference range. See http://hl7.org/fhir/ValueSet/referencerange-meaning
	Meaning *CodeableConcept `form:"meaning,omitempty" json:"meaning,omitempty" xml:"meaning,omitempty"`
	// Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.
	// 		An example would be a reference value of "Negative" or a list or table of 'normals'.
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
}

// Validate validates the ReferenceRange media type instance.
func (mt *ReferenceRange) Validate() (err error) {
	if mt.Age != nil {
		if err2 := mt.Age.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.High != nil {
		if err2 := mt.High.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Low != nil {
		if err2 := mt.Low.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeReferenceRange decodes the ReferenceRange instance encoded in resp body.
func (c *Client) DecodeReferenceRange(resp *http.Response) (*ReferenceRange, error) {
	var decoded ReferenceRange
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// ReferenceRangeCollection is the media type for an array of ReferenceRange (default view)
//
// Identifier: application/vnd.reference.range+json; type=collection; view=default
type ReferenceRangeCollection []*ReferenceRange

// Validate validates the ReferenceRangeCollection media type instance.
func (mt ReferenceRangeCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeReferenceRangeCollection decodes the ReferenceRangeCollection instance encoded in resp body.
func (c *Client) DecodeReferenceRangeCollection(resp *http.Response) (ReferenceRangeCollection, error) {
	var decoded ReferenceRangeCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// A  reference to another resource (usually another Observation but could  also be a QuestionnaireAnswer) whose relationship is defined by the relationship type code. (default view)
//
// Identifier: application/vnd.related+json; view=default
type Related struct {
	// A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation.
	Target *CodeableConcept `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// A code specifying the kind of relationship that exists with the target resource. See http://hl7.org/fhir/ValueSet/observation-relationshiptypes
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// DecodeRelated decodes the Related instance encoded in resp body.
func (c *Client) DecodeRelated(resp *http.Response) (*Related, error) {
	var decoded Related
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RelatedCollection is the media type for an array of Related (default view)
//
// Identifier: application/vnd.related+json; type=collection; view=default
type RelatedCollection []*Related

// DecodeRelatedCollection decodes the RelatedCollection instance encoded in resp body.
func (c *Client) DecodeRelatedCollection(resp *http.Response) (RelatedCollection, error) {
	var decoded RelatedCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Repeat media type (default view)
//
// Identifier: application/vnd.repeat+json; view=default
type Repeat struct {
	// Length/Range of lengths, or (Start and/or end) limits
	Bounds *interface{} `form:"bounds,omitempty" json:"bounds,omitempty" xml:"bounds,omitempty"`
	// A total count of the desired number of repetitions.
	Count *int `form:"count,omitempty" json:"count,omitempty" xml:"count,omitempty"`
	// How long this thing happens for when it happens.
	Duration *float64 `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The units of time for the duration, in UCUM units. See http://hl7.org/fhir/ValueSet/units-of-time
	DurationUnits *string `form:"durationUnits,omitempty" json:"durationUnits,omitempty" xml:"durationUnits,omitempty"`
	// The number of times to repeat the action within the specified period / period range (i.e. both period and periodMax provided).
	Frequency *int `form:"frequency,omitempty" json:"frequency,omitempty" xml:"frequency,omitempty"`
	// If present, indicates that the frequency is a range - so repeat between [frequency] and [frequencyMax] times within the period or period range.
	FrequencyMax *int `form:"frequencyMax,omitempty" json:"frequencyMax,omitempty" xml:"frequencyMax,omitempty"`
	// Event occurs frequency times per period
	Period *float64 `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as 'do this once every 3-5 days.'
	PeriodMax *string `form:"periodMax,omitempty" json:"periodMax,omitempty" xml:"periodMax,omitempty"`
	// The units of time for the period in UCUM units. See http://hl7.org/fhir/ValueSet/units-of-time
	PeriodUnits *string `form:"periodUnits,omitempty" json:"periodUnits,omitempty" xml:"periodUnits,omitempty"`
	// A real world event that the occurrence of the event should be tied to. See http://hl7.org/fhir/ValueSet/event-timing
	When *string `form:"when,omitempty" json:"when,omitempty" xml:"when,omitempty"`
}

// Validate validates the Repeat media type instance.
func (mt *Repeat) Validate() (err error) {
	if mt.DurationUnits != nil {
		if !(*mt.DurationUnits == "s" || *mt.DurationUnits == "min" || *mt.DurationUnits == "h" || *mt.DurationUnits == "d" || *mt.DurationUnits == "wk" || *mt.DurationUnits == "mo" || *mt.DurationUnits == "a") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.durationUnits`, *mt.DurationUnits, []interface{}{"s", "min", "h", "d", "wk", "mo", "a"}))
		}
	}
	if mt.PeriodUnits != nil {
		if !(*mt.PeriodUnits == "s" || *mt.PeriodUnits == "min" || *mt.PeriodUnits == "h" || *mt.PeriodUnits == "d" || *mt.PeriodUnits == "wk" || *mt.PeriodUnits == "mo" || *mt.PeriodUnits == "a") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.periodUnits`, *mt.PeriodUnits, []interface{}{"s", "min", "h", "d", "wk", "mo", "a"}))
		}
	}
	return
}

// DecodeRepeat decodes the Repeat instance encoded in resp body.
func (c *Client) DecodeRepeat(resp *http.Response) (*Repeat, error) {
	var decoded Repeat
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// SampleData media type (default view)
//
// Identifier: application/vnd.sample.data+json; view=default
type SampleData struct {
	// A series of data points which are decimal values separated by a single space (character u20). The special values 'E' (error), 'L' (below detection limit) and 'U' (above detection limit) can also be used in place of a decimal value.
	Data *string `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// The upper limit of detection of the measured points. This is needed if any of the data points have the value 'U' (higher than detection limit).
	Dimensions *int `form:"dimensions,omitempty" json:"dimensions,omitempty" xml:"dimensions,omitempty"`
	// A correction factor that is applied to the sampled data points before they are added to the origin.
	Factor *float64 `form:"factor,omitempty" json:"factor,omitempty" xml:"factor,omitempty"`
	// The lower limit of detection of the measured points. This is needed if any of the data points have the value 'L' (lower than detection limit).
	LowerLimit *float64 `form:"lowerLimit,omitempty" json:"lowerLimit,omitempty" xml:"lowerLimit,omitempty"`
	// The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
	Origin *Quantity `form:"origin,omitempty" json:"origin,omitempty" xml:"origin,omitempty"`
	// The length of time between sampling times, measured in milliseconds.
	Period *float64 `form:"period,omitempty" json:"period,omitempty" xml:"period,omitempty"`
	// The upper limit of detection of the measured points. This is needed if any of the data points have the value 'U' (higher than detection limit).
	UpperLimit *float64 `form:"upperLimit,omitempty" json:"upperLimit,omitempty" xml:"upperLimit,omitempty"`
}

// Validate validates the SampleData media type instance.
func (mt *SampleData) Validate() (err error) {
	if mt.Origin != nil {
		if err2 := mt.Origin.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeSampleData decodes the SampleData instance encoded in resp body.
func (c *Client) DecodeSampleData(resp *http.Response) (*SampleData, error) {
	var decoded SampleData
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Supplement media type (default view)
//
// Identifier: application/vnd.supplement+json; view=default
type Supplement struct {
	// Free text or additional instructions or information pertaining to the oral supplement.
	Instruction *string `form:"instruction,omitempty" json:"instruction,omitempty" xml:"instruction,omitempty"`
	// The product or brand name of the nutritional supplement such as 'Acme Protein Shake'.
	ProductName *string `form:"productName,omitempty" json:"productName,omitempty" xml:"productName,omitempty"`
	// The amount of the nutritional supplement to be given.
	Quantity *Quantity `form:"quantity,omitempty" json:"quantity,omitempty" xml:"quantity,omitempty"`
	// The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement.
	Type *CodeableConcept `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the Supplement media type instance.
func (mt *Supplement) Validate() (err error) {
	if mt.Quantity != nil {
		if err2 := mt.Quantity.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeSupplement decodes the Supplement instance encoded in resp body.
func (c *Client) DecodeSupplement(resp *http.Response) (*Supplement, error) {
	var decoded Supplement
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Texture media type (default view)
//
// Identifier: application/vnd.texture+json; view=default
type Texture struct {
	// The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. See http://hl7.org/fhir/ValueSet/modified-foodtype
	FoodType *CodeableConcept `form:"foodType,omitempty" json:"foodType,omitempty" xml:"foodType,omitempty"`
	// Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. See http://hl7.org/fhir/ValueSet/texture-code
	Modifier *CodeableConcept `form:"modifier,omitempty" json:"modifier,omitempty" xml:"modifier,omitempty"`
}

// DecodeTexture decodes the Texture instance encoded in resp body.
func (c *Client) DecodeTexture(resp *http.Response) (*Texture, error) {
	var decoded Texture
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Timing media type (default view)
//
// Identifier: application/vnd.timing+json; view=default
type Timing struct {
	// A code for the timing pattern. Some codes such as BID are ubiquitous, but many institutions define their own additional codes. See http://hl7.org/fhir/ValueSet/timing-abbreviation
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Identifies specific times when the event occurs.
	Event *time.Time `form:"event,omitempty" json:"event,omitempty" xml:"event,omitempty"`
	// A set of rules that describe when the event should occur.
	Repeat *Element `form:"repeat,omitempty" json:"repeat,omitempty" xml:"repeat,omitempty"`
}

// Validate validates the Timing media type instance.
func (mt *Timing) Validate() (err error) {
	if mt.Code != nil {
		if !(*mt.Code == "QD" || *mt.Code == "QOD" || *mt.Code == "Q4H" || *mt.Code == "Q6H" || *mt.Code == "BID" || *mt.Code == "TID" || *mt.Code == "QID" || *mt.Code == "AM" || *mt.Code == "PM +") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.code`, *mt.Code, []interface{}{"QD", "QOD", "Q4H", "Q6H", "BID", "TID", "QID", "AM", "PM +"}))
		}
	}
	if mt.Repeat != nil {
		if err2 := mt.Repeat.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeTiming decodes the Timing instance encoded in resp body.
func (c *Client) DecodeTiming(resp *http.Response) (*Timing, error) {
	var decoded Timing
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// A user of the API (default view)
//
// Identifier: application/vnd.user+json; view=default
type User struct {
	// Name of city, town etc.
	AddressCity *string `form:"address_city,omitempty" json:"address_city,omitempty" xml:"address_city,omitempty"`
	// Street name, number, direction & P.O. Box etc.
	AddressLine *string `form:"address_line,omitempty" json:"address_line,omitempty" xml:"address_line,omitempty"`
	// Postal code for area
	AddressPostalCode *int `form:"address_postal_code,omitempty" json:"address_postal_code,omitempty" xml:"address_postal_code,omitempty"`
	// Sub-unit of country (abbreviations ok)
	AddressState *string `form:"address_state,omitempty" json:"address_state,omitempty" xml:"address_state,omitempty"`
	// Date of creation
	CreatedAt time.Time `form:"created_at" json:"created_at" xml:"created_at"`
	// Email of user owner
	CreatedBy string `form:"created_by" json:"created_by" xml:"created_by"`
	// Email of user
	Email string `form:"email" json:"email" xml:"email"`
	// First name of user
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// API href of user
	Href string `form:"href" json:"href" xml:"href"`
	// ID of user
	ID int `form:"id" json:"id" xml:"id"`
	// Last name of user
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// Username of user
	Username string `form:"username" json:"username" xml:"username"`
}

// Validate validates the User media type instance.
func (mt *User) Validate() (err error) {

	if mt.Href == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "href"))
	}
	if mt.Username == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "username"))
	}
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "first_name"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "last_name"))
	}

	if mt.CreatedBy == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "created_by"))
	}
	if mt.AddressCity != nil {
		if utf8.RuneCountInString(*mt.AddressCity) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.address_city`, *mt.AddressCity, utf8.RuneCountInString(*mt.AddressCity), 2, true))
		}
	}
	if mt.AddressLine != nil {
		if utf8.RuneCountInString(*mt.AddressLine) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.address_line`, *mt.AddressLine, utf8.RuneCountInString(*mt.AddressLine), 2, true))
		}
	}
	if mt.AddressPostalCode != nil {
		if len(*mt.AddressPostalCode) < 5 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.address_postal_code`, *mt.AddressPostalCode, len(*mt.AddressPostalCode), 5, true))
		}
	}
	if mt.AddressState != nil {
		if utf8.RuneCountInString(*mt.AddressState) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.address_state`, *mt.AddressState, utf8.RuneCountInString(*mt.AddressState), 2, true))
		}
	}
	if err2 := goa.ValidateFormat(goa.FormatEmail, mt.CreatedBy); err2 != nil {
		err = goa.MergeErrors(err, goa.InvalidFormatError(`response.created_by`, mt.CreatedBy, goa.FormatEmail, err2))
	}
	if err2 := goa.ValidateFormat(goa.FormatEmail, mt.Email); err2 != nil {
		err = goa.MergeErrors(err, goa.InvalidFormatError(`response.email`, mt.Email, goa.FormatEmail, err2))
	}
	if utf8.RuneCountInString(mt.Email) < 4 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.email`, mt.Email, utf8.RuneCountInString(mt.Email), 4, true))
	}
	if utf8.RuneCountInString(mt.FirstName) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.first_name`, mt.FirstName, utf8.RuneCountInString(mt.FirstName), 2, true))
	}
	if utf8.RuneCountInString(mt.LastName) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.last_name`, mt.LastName, utf8.RuneCountInString(mt.LastName), 2, true))
	}
	if utf8.RuneCountInString(mt.Username) < 3 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.username`, mt.Username, utf8.RuneCountInString(mt.Username), 3, true))
	}
	return
}

// A user of the API (link view)
//
// Identifier: application/vnd.user+json; view=link
type UserLink struct {
	// API href of user
	Href string `form:"href" json:"href" xml:"href"`
	// ID of user
	ID int `form:"id" json:"id" xml:"id"`
}

// Validate validates the UserLink media type instance.
func (mt *UserLink) Validate() (err error) {

	if mt.Href == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "href"))
	}
	return
}

// A user of the API (tiny view)
//
// Identifier: application/vnd.user+json; view=tiny
type UserTiny struct {
	// Email of user
	Email string `form:"email" json:"email" xml:"email"`
	// First name of user
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// API href of user
	Href string `form:"href" json:"href" xml:"href"`
	// ID of user
	ID int `form:"id" json:"id" xml:"id"`
	// Last name of user
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// Username of user
	Username string `form:"username" json:"username" xml:"username"`
}

// Validate validates the UserTiny media type instance.
func (mt *UserTiny) Validate() (err error) {

	if mt.Href == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "href"))
	}
	if mt.Username == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "username"))
	}
	if mt.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "email"))
	}
	if mt.FirstName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "first_name"))
	}
	if mt.LastName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "last_name"))
	}
	if err2 := goa.ValidateFormat(goa.FormatEmail, mt.Email); err2 != nil {
		err = goa.MergeErrors(err, goa.InvalidFormatError(`response.email`, mt.Email, goa.FormatEmail, err2))
	}
	if utf8.RuneCountInString(mt.Email) < 4 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.email`, mt.Email, utf8.RuneCountInString(mt.Email), 4, true))
	}
	if utf8.RuneCountInString(mt.FirstName) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.first_name`, mt.FirstName, utf8.RuneCountInString(mt.FirstName), 2, true))
	}
	if utf8.RuneCountInString(mt.LastName) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.last_name`, mt.LastName, utf8.RuneCountInString(mt.LastName), 2, true))
	}
	if utf8.RuneCountInString(mt.Username) < 3 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.username`, mt.Username, utf8.RuneCountInString(mt.Username), 3, true))
	}
	return
}

// DecodeUser decodes the User instance encoded in resp body.
func (c *Client) DecodeUser(resp *http.Response) (*User, error) {
	var decoded User
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeUserLink decodes the UserLink instance encoded in resp body.
func (c *Client) DecodeUserLink(resp *http.Response) (*UserLink, error) {
	var decoded UserLink
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeUserTiny decodes the UserTiny instance encoded in resp body.
func (c *Client) DecodeUserTiny(resp *http.Response) (*UserTiny, error) {
	var decoded UserTiny
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// UserCollection is the media type for an array of User (default view)
//
// Identifier: application/vnd.user+json; type=collection; view=default
type UserCollection []*User

// Validate validates the UserCollection media type instance.
func (mt UserCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// UserCollection is the media type for an array of User (link view)
//
// Identifier: application/vnd.user+json; type=collection; view=link
type UserLinkCollection []*UserLink

// Validate validates the UserLinkCollection media type instance.
func (mt UserLinkCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// UserCollection is the media type for an array of User (tiny view)
//
// Identifier: application/vnd.user+json; type=collection; view=tiny
type UserTinyCollection []*UserTiny

// Validate validates the UserTinyCollection media type instance.
func (mt UserTinyCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeUserCollection decodes the UserCollection instance encoded in resp body.
func (c *Client) DecodeUserCollection(resp *http.Response) (UserCollection, error) {
	var decoded UserCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeUserLinkCollection decodes the UserLinkCollection instance encoded in resp body.
func (c *Client) DecodeUserLinkCollection(resp *http.Response) (UserLinkCollection, error) {
	var decoded UserLinkCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeUserTinyCollection decodes the UserTinyCollection instance encoded in resp body.
func (c *Client) DecodeUserTinyCollection(resp *http.Response) (UserTinyCollection, error) {
	var decoded UserTinyCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}
