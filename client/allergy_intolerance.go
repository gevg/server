// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/goa-fhir/server/design
// --out=$(GOPATH)\src\github.com\goa-fhir\server
// --version=v1.1.0-dirty
//
// API "Secure": AllergyIntolerance Resource Client
//
// The content of this file is auto-generated, DO NOT MODIFY

package client

import (
	"bytes"
	"fmt"
	"golang.org/x/net/context"
	"golang.org/x/net/websocket"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// CreateAllergyIntolerancePayload is the AllergyIntolerance create action payload.
type CreateAllergyIntolerancePayload struct {
	// Category of the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-category
	Category *string `form:"category,omitempty" json:"category,omitempty" xml:"category,omitempty"`
	// Estimate of the potential clinical harm, or seriousness, of the reaction to the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality
	Criticality *string `form:"criticality,omitempty" json:"criticality,omitempty" xml:"criticality,omitempty"`
	// This records identifiers associated with this allergy/intolerance concern that are defined by business processes and/or
	// 		used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
	Identifier []*Identifier `form:"identifier,omitempty" json:"identifier,omitempty" xml:"identifier,omitempty"`
	// Represents the date and/or time of the last known occurrence of a reaction event.
	LastOccurence *time.Time `form:"lastOccurence,omitempty" json:"lastOccurence,omitempty" xml:"lastOccurence,omitempty"`
	// The metadata about a resource. This is content in the resource that is maintained by the infrastructure.
	// 	Changes to the content may not always be associated with version changes to the resource.
	Meta *Meta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// Additional narrative about the propensity for the Adverse Reaction, not captured in other fields..
	Note *Annotation `form:"note,omitempty" json:"note,omitempty" xml:"note,omitempty"`
	// Record of the date and/or time of the onset of the Allergy or Intolerance.
	Onset *time.Time `form:"onset,omitempty" json:"onset,omitempty" xml:"onset,omitempty"`
	// The patient who has the allergy or intolerance.
	Patient *HL7Reference `form:"patient,omitempty" json:"patient,omitempty" xml:"patient,omitempty"`
	// Details about each adverse reaction event linked to exposure to the identified Substance.
	Reaction *Reaction `form:"reaction,omitempty" json:"reaction,omitempty" xml:"reaction,omitempty"`
	// Date when the sensitivity was recorded.
	RecordedDate *time.Time `form:"recordedDate,omitempty" json:"recordedDate,omitempty" xml:"recordedDate,omitempty"`
	// Individual who recorded the record and takes responsibility for its conten.
	Recorder *HL7Reference `form:"recorder,omitempty" json:"recorder,omitempty" xml:"recorder,omitempty"`
	// The source of the information about the allergy that is recorded.
	Reporter *HL7Reference `form:"reporter,omitempty" json:"reporter,omitempty" xml:"reporter,omitempty"`
	// Assertion about certainty associated with a propensity, or potential risk, of a reaction to the identified Substance. See http://hl7.org/fhir/ValueSet/allergy-intolerance-status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identification of the underlying physiological mechanism for the reaction risk. See http://hl7.org/fhir/ValueSet/allergy-intolerance-type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// CreateAllergyIntolerancePath computes a request path to the create action of AllergyIntolerance.
func CreateAllergyIntolerancePath(patientID int) string {
	param0 := strconv.Itoa(patientID)

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance", param0)
}

// Record new vital
func (c *Client) CreateAllergyIntolerance(ctx context.Context, path string, payload *CreateAllergyIntolerancePayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Response, error) {
	req, err := c.NewCreateAllergyIntoleranceRequest(ctx, path, payload, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateAllergyIntoleranceRequest create the request corresponding to the create action endpoint of the AllergyIntolerance resource.
func (c *Client) NewCreateAllergyIntoleranceRequest(ctx context.Context, path string, payload *CreateAllergyIntolerancePayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp86 := strconv.Itoa(*count)
		values.Set("_count", tmp86)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp87 := strconv.Itoa(*id)
		values.Set("_id", tmp87)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp88 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp88)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// DeleteAllergyIntolerancePath computes a request path to the delete action of AllergyIntolerance.
func DeleteAllergyIntolerancePath(patientID int, allergy string) string {
	param0 := strconv.Itoa(patientID)
	param1 := allergy

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance/%s.intoleranceID", param0, param1)
}

// DeleteAllergyIntolerance makes a request to the delete action endpoint of the AllergyIntolerance resource
func (c *Client) DeleteAllergyIntolerance(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Response, error) {
	req, err := c.NewDeleteAllergyIntoleranceRequest(ctx, path, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_, allergyIntoleranceID)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteAllergyIntoleranceRequest create the request corresponding to the delete action endpoint of the AllergyIntolerance resource.
func (c *Client) NewDeleteAllergyIntoleranceRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp89 := strconv.Itoa(*count)
		values.Set("_count", tmp89)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp90 := strconv.Itoa(*id)
		values.Set("_id", tmp90)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp91 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp91)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	if allergyIntoleranceID != nil {
		tmp92 := strconv.Itoa(*allergyIntoleranceID)
		values.Set("allergy.intoleranceID", tmp92)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ListAllergyIntolerancePath computes a request path to the list action of AllergyIntolerance.
func ListAllergyIntolerancePath(patientID int) string {
	param0 := strconv.Itoa(patientID)

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance", param0)
}

// List all allergy_intolerances in patient optionally filtering by year
func (c *Client) ListAllergyIntolerance(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, years []int) (*http.Response, error) {
	req, err := c.NewListAllergyIntoleranceRequest(ctx, path, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_, years)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListAllergyIntoleranceRequest create the request corresponding to the list action endpoint of the AllergyIntolerance resource.
func (c *Client) NewListAllergyIntoleranceRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, years []int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp93 := strconv.Itoa(*count)
		values.Set("_count", tmp93)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp94 := strconv.Itoa(*id)
		values.Set("_id", tmp94)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp95 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp95)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	for _, p := range years {
		tmp96 := strconv.Itoa(p)
		values.Add("years", tmp96)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// RateAllergyIntolerancePayload is the AllergyIntolerance rate action payload.
type RateAllergyIntolerancePayload struct {
	Rating string `form:"rating" json:"rating" xml:"rating"`
}

// RateAllergyIntolerancePath computes a request path to the rate action of AllergyIntolerance.
func RateAllergyIntolerancePath(patientID int, allergy string) string {
	param0 := strconv.Itoa(patientID)
	param1 := allergy

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance/%s.intoleranceID/actions/rate", param0, param1)
}

// RateAllergyIntolerance makes a request to the rate action endpoint of the AllergyIntolerance resource
func (c *Client) RateAllergyIntolerance(ctx context.Context, path string, payload *RateAllergyIntolerancePayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Response, error) {
	req, err := c.NewRateAllergyIntoleranceRequest(ctx, path, payload, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_, allergyIntoleranceID)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRateAllergyIntoleranceRequest create the request corresponding to the rate action endpoint of the AllergyIntolerance resource.
func (c *Client) NewRateAllergyIntoleranceRequest(ctx context.Context, path string, payload *RateAllergyIntolerancePayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp97 := strconv.Itoa(*count)
		values.Set("_count", tmp97)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp98 := strconv.Itoa(*id)
		values.Set("_id", tmp98)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp99 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp99)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	if allergyIntoleranceID != nil {
		tmp100 := strconv.Itoa(*allergyIntoleranceID)
		values.Set("allergy.intoleranceID", tmp100)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReadAllergyIntolerancePath computes a request path to the read action of AllergyIntolerance.
func ReadAllergyIntolerancePath(patientID int, allergy string) string {
	param0 := strconv.Itoa(patientID)
	param1 := allergy

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance/%s.intoleranceID", param0, param1)
}

// Retrieve vital with given id
func (c *Client) ReadAllergyIntolerance(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Response, error) {
	req, err := c.NewReadAllergyIntoleranceRequest(ctx, path, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_, allergyIntoleranceID)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewReadAllergyIntoleranceRequest create the request corresponding to the read action endpoint of the AllergyIntolerance resource.
func (c *Client) NewReadAllergyIntoleranceRequest(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp101 := strconv.Itoa(*count)
		values.Set("_count", tmp101)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp102 := strconv.Itoa(*id)
		values.Set("_id", tmp102)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp103 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp103)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	if allergyIntoleranceID != nil {
		tmp104 := strconv.Itoa(*allergyIntoleranceID)
		values.Set("allergy.intoleranceID", tmp104)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateAllergyIntolerancePath computes a request path to the update action of AllergyIntolerance.
func UpdateAllergyIntolerancePath(patientID int, allergy string) string {
	param0 := strconv.Itoa(patientID)
	param1 := allergy

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance/%s.intoleranceID", param0, param1)
}

// UpdateAllergyIntolerance makes a request to the update action endpoint of the AllergyIntolerance resource
func (c *Client) UpdateAllergyIntolerance(ctx context.Context, path string, payload *AllergyIntolerancePayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Response, error) {
	req, err := c.NewUpdateAllergyIntoleranceRequest(ctx, path, payload, contained, containedType, count, elements, has, id, include, lastUpdate, list, profile, query, revinclude, security, sort, summary, tag, text, type_, allergyIntoleranceID)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateAllergyIntoleranceRequest create the request corresponding to the update action endpoint of the AllergyIntolerance resource.
func (c *Client) NewUpdateAllergyIntoleranceRequest(ctx context.Context, path string, payload *AllergyIntolerancePayload, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp105 := strconv.Itoa(*count)
		values.Set("_count", tmp105)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp106 := strconv.Itoa(*id)
		values.Set("_id", tmp106)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp107 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp107)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	if allergyIntoleranceID != nil {
		tmp108 := strconv.Itoa(*allergyIntoleranceID)
		values.Set("allergy.intoleranceID", tmp108)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PATCH", u.String(), &body)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// WatchAllergyIntolerancePath computes a request path to the watch action of AllergyIntolerance.
func WatchAllergyIntolerancePath(patientID int, allergy string) string {
	param0 := strconv.Itoa(patientID)
	param1 := allergy

	return fmt.Sprintf("/nosh/patients/%s/allergy.intolerance/%s.intoleranceID/watch", param0, param1)
}

// Retrieve vital with given id
func (c *Client) WatchAllergyIntolerance(ctx context.Context, path string, contained *string, containedType *string, count *int, elements *string, has *string, id *int, include *string, lastUpdate *time.Time, list *string, profile *string, query *string, revinclude *string, security *string, sort *string, summary *string, tag *string, text *string, type_ *string, allergyIntoleranceID *int) (*websocket.Conn, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "ws"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if contained != nil {
		values.Set("_contained", *contained)
	}
	if containedType != nil {
		values.Set("_containedType", *containedType)
	}
	if count != nil {
		tmp109 := strconv.Itoa(*count)
		values.Set("_count", tmp109)
	}
	if elements != nil {
		values.Set("_elements", *elements)
	}
	if has != nil {
		values.Set("_has", *has)
	}
	if id != nil {
		tmp110 := strconv.Itoa(*id)
		values.Set("_id", tmp110)
	}
	if include != nil {
		values.Set("_include", *include)
	}
	if lastUpdate != nil {
		tmp111 := lastUpdate.Format(time.RFC3339)
		values.Set("_lastUpdate", tmp111)
	}
	if list != nil {
		values.Set("_list", *list)
	}
	if profile != nil {
		values.Set("_profile", *profile)
	}
	if query != nil {
		values.Set("_query", *query)
	}
	if revinclude != nil {
		values.Set("_revinclude", *revinclude)
	}
	if security != nil {
		values.Set("_security", *security)
	}
	if sort != nil {
		values.Set("_sort", *sort)
	}
	if summary != nil {
		values.Set("_summary", *summary)
	}
	if tag != nil {
		values.Set("_tag", *tag)
	}
	if text != nil {
		values.Set("_text", *text)
	}
	if type_ != nil {
		values.Set("_type", *type_)
	}
	if allergyIntoleranceID != nil {
		tmp112 := strconv.Itoa(*allergyIntoleranceID)
		values.Set("allergy.intoleranceID", tmp112)
	}
	u.RawQuery = values.Encode()
	url_ := u.String()
	cfg, err := websocket.NewConfig(url_, url_)
	if err != nil {
		return nil, err
	}
	return websocket.DialConfig(cfg)
}
