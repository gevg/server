// Code generated by goagen v1.1.0-dirty, command line:
// $ goagen
// --design=github.com/goa-fhir/server/design
// --out=$(GOPATH)\src\github.com\goa-fhir\server
// --version=v1.1.0-dirty
//
// API "goa-FHIR": CLI Commands
//
// The content of this file is auto-generated, DO NOT MODIFY

package cli

import (
	"encoding/json"
	"fmt"
	"github.com/goa-fhir/server/client"
	"github.com/goadesign/goa"
	goaclient "github.com/goadesign/goa/client"
	uuid "github.com/goadesign/goa/uuid"
	"github.com/spf13/cobra"
	"golang.org/x/net/context"
	"log"
	"net/url"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

type (
	// ReadAllergyIntoleranceCommand is the command line data structure for the read action of AllergyIntolerance
	ReadAllergyIntoleranceCommand struct {
		Allergy string
		// Patient ID
		PatientID            int
		Contained            string
		ContainedType        string
		Count                int
		Elements             string
		Has                  string
		ID                   int
		Include              string
		LastUpdate           string
		List                 string
		Profile              string
		Query                string
		Revinclude           string
		Security             string
		Sort                 string
		Summary              string
		Tag                  string
		Text                 string
		Type                 string
		AllergyIntoleranceID int
		PrettyPrint          bool
	}

	// ReadNutritionRequestCommand is the command line data structure for the read action of NutritionRequest
	ReadNutritionRequestCommand struct {
		NutritionRequestID int
		// Patient ID
		PatientID     int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// ShowObservationCommand is the command line data structure for the show action of Observation
	ShowObservationCommand struct {
		ObservationID int
		// Patient ID
		PatientID     int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// HealthHealthCommand is the command line data structure for the health action of health
	HealthHealthCommand struct {
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// AuthorizeOauth2ProviderCommand is the command line data structure for the authorize action of oauth2_provider
	AuthorizeOauth2ProviderCommand struct {
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		// The client identifier
		ClientID string
		// Redirection endpoint
		RedirectURI string
		// Value MUST be set to "code"
		ResponseType string
		// The scope of the access request
		Scope string
		// An opaque value used by the client to maintain state between the request and callback
		State       string
		PrettyPrint bool
	}

	// GetTokenOauth2ProviderCommand is the command line data structure for the get_token action of oauth2_provider
	GetTokenOauth2ProviderCommand struct {
		Payload       string
		ContentType   string
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// CreatePatientCommand is the command line data structure for the create action of patient
	CreatePatientCommand struct {
		Payload       string
		ContentType   string
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// DeletePatientCommand is the command line data structure for the delete action of patient
	DeletePatientCommand struct {
		// Patient ID
		PatientID     int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// ReadPatientCommand is the command line data structure for the read action of patient
	ReadPatientCommand struct {
		Payload     string
		ContentType string
		// Patient ID
		PatientID     int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// SearchPatientCommand is the command line data structure for the search action of patient
	SearchPatientCommand struct {
		Payload       string
		ContentType   string
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		// Filter by active
		Active string
		// Filter by birth date
		BirthDate []string
		// Filter by gender
		Gender string
		// Filter by name
		Name        []string
		PrettyPrint bool
	}

	// UpdatePatientCommand is the command line data structure for the update action of patient
	UpdatePatientCommand struct {
		Payload     string
		ContentType string
		// Patient ID
		PatientID     int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// VreadPatientCommand is the command line data structure for the vread action of patient
	VreadPatientCommand struct {
		Payload     string
		ContentType string
		// Patient ID
		PatientID     int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// CreateUserCommand is the command line data structure for the create action of user
	CreateUserCommand struct {
		Payload       string
		ContentType   string
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// DeleteUserCommand is the command line data structure for the delete action of user
	DeleteUserCommand struct {
		// User ID
		UserID        int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// ListUserCommand is the command line data structure for the list action of user
	ListUserCommand struct {
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// SecureUserCommand is the command line data structure for the secure action of user
	SecureUserCommand struct {
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		// Force auth failure via JWT validation middleware
		Fail        string
		PrettyPrint bool
	}

	// ShowUserCommand is the command line data structure for the show action of user
	ShowUserCommand struct {
		// User ID
		UserID        int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// SigninUserCommand is the command line data structure for the signin action of user
	SigninUserCommand struct {
		Payload       string
		ContentType   string
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// SignupUserCommand is the command line data structure for the signup action of user
	SignupUserCommand struct {
		Payload       string
		ContentType   string
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// UnsecureUserCommand is the command line data structure for the unsecure action of user
	UnsecureUserCommand struct {
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// UpdateUserCommand is the command line data structure for the update action of user
	UpdateUserCommand struct {
		Payload     string
		ContentType string
		// User ID
		UserID        int
		Contained     string
		ContainedType string
		Count         int
		Elements      string
		Has           string
		ID            int
		Include       string
		LastUpdate    string
		List          string
		Profile       string
		Query         string
		Revinclude    string
		Security      string
		Sort          string
		Summary       string
		Tag           string
		Text          string
		Type          string
		PrettyPrint   bool
	}

	// DownloadCommand is the command line data structure for the download command.
	DownloadCommand struct {
		// OutFile is the path to the download output file.
		OutFile string
	}
)

// RegisterCommands registers the resource action CLI commands.
func RegisterCommands(app *cobra.Command, c *client.Client) {
	var command, sub *cobra.Command
	command = &cobra.Command{
		Use:   "authorize",
		Short: `Authorize OAuth2 client`,
	}
	tmp1 := new(AuthorizeOauth2ProviderCommand)
	sub = &cobra.Command{
		Use:   `oauth2_provider ["/nosh/oauth2/auth"]`,
		Short: `This resource implements the OAuth2 authorization code flow`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp1.Run(c, args) },
	}
	tmp1.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp1.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "create",
		Short: `create action`,
	}
	tmp2 := new(CreatePatientCommand)
	sub = &cobra.Command{
		Use:   `patient ["/nosh/patients"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "name": [
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp2.Run(c, args) },
	}
	tmp2.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp2.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp3 := new(CreateUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "email": "jim.smith@gmail.com",
   "password": "Quod possimus est dolores praesentium."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp3.Run(c, args) },
	}
	tmp3.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp3.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "delete",
		Short: `delete action`,
	}
	tmp4 := new(DeletePatientCommand)
	sub = &cobra.Command{
		Use:   `patient ["/nosh/patients/PATIENTID"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp4.Run(c, args) },
	}
	tmp4.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp4.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp5 := new(DeleteUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/USERID"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp5.Run(c, args) },
	}
	tmp5.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp5.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "getToken",
		Short: `Get access token from authorization code or refresh token`,
	}
	tmp6 := new(GetTokenOauth2ProviderCommand)
	sub = &cobra.Command{
		Use:   `oauth2_provider ["/nosh/oauth2/token"]`,
		Short: `This resource implements the OAuth2 authorization code flow`,
		Long: `This resource implements the OAuth2 authorization code flow

Payload example:

{
   "code": "Quae laborum voluptate.",
   "grant_type": "refresh_token",
   "redirect_uri": "Corrupti quia.",
   "refresh_token": "Quis rerum.",
   "scope": "Odit vel nobis exercitationem."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp6.Run(c, args) },
	}
	tmp6.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp6.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "health",
		Short: `Perform health check.`,
	}
	tmp7 := new(HealthHealthCommand)
	sub = &cobra.Command{
		Use:   `health ["/nosh/_ah/health"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp7.Run(c, args) },
	}
	tmp7.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp7.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list",
		Short: `Retrieve all users.`,
	}
	tmp8 := new(ListUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp8.Run(c, args) },
	}
	tmp8.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp8.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "read",
		Short: `read action`,
	}
	tmp9 := new(ReadAllergyIntoleranceCommand)
	sub = &cobra.Command{
		Use:   `AllergyIntolerance ["/nosh/patients/PATIENTID/allergy.intolerance/ALLERGY.intoleranceID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp9.Run(c, args) },
	}
	tmp9.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp9.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp10 := new(ReadNutritionRequestCommand)
	sub = &cobra.Command{
		Use:   `NutritionRequest ["/nosh/patients/PATIENTID/nutrition.requests/NUTRITION_REQUESTID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp10.Run(c, args) },
	}
	tmp10.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp10.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp11 := new(ReadPatientCommand)
	sub = &cobra.Command{
		Use:   `patient ["/nosh/patients/PATIENTID"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "active": false,
   "address": [
      {
         "city": "Eaque vero quasi quod.",
         "country": "Enim sit porro asperiores aspernatur dolorem.",
         "distinct": "Modi provident earum aut quam dolorem sit.",
         "line": [
            "Est asperiores laboriosam consectetur voluptatem et."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "postalCode": "Consectetur ut.",
         "state": "Et dolorem.",
         "text": "Maxime eius rerum quia sunt neque.",
         "type": "both",
         "use": "work"
      }
   ],
   "animal": {
      "breed": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      },
      "genderStatus": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      },
      "species": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      }
   },
   "birthDate": "2000-05-04T09:23:10-04:00",
   "careProvider": {
      "display": "Eaque et expedita omnis officiis illo.",
      "reference": "Nisi culpa."
   },
   "communication": [
      {
         "careProvider": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "language": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "preferred": true
      }
   ],
   "contact": [
      {
         "address": {
            "city": "Eaque vero quasi quod.",
            "country": "Enim sit porro asperiores aspernatur dolorem.",
            "distinct": "Modi provident earum aut quam dolorem sit.",
            "line": [
               "Est asperiores laboriosam consectetur voluptatem et."
            ],
            "period": {
               "end": "1981-07-03T17:26:51-04:00",
               "start": "1998-04-13T16:02:45-04:00"
            },
            "postalCode": "Consectetur ut.",
            "state": "Et dolorem.",
            "text": "Maxime eius rerum quia sunt neque.",
            "type": "both",
            "use": "work"
         },
         "careProvider": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "gender": "other",
         "language": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "name": {
            "family": [
               "Repudiandae aut qui doloribus voluptate."
            ],
            "given": [
               "Tenetur ut fugit occaecati sequi amet."
            ],
            "period": {
               "end": "1981-07-03T17:26:51-04:00",
               "start": "1998-04-13T16:02:45-04:00"
            },
            "prefix": [
               "Similique nostrum nemo illum aperiam.",
               "Similique nostrum nemo illum aperiam.",
               "Similique nostrum nemo illum aperiam."
            ],
            "suffix": [
               "Qui veritatis quidem nihil."
            ],
            "use": "old"
         },
         "organization": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "preferred": false,
         "relationship": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "telecom": {
            "rank": 8423925307476269937,
            "system": "phone",
            "use": "work",
            "value": "Dignissimos placeat nemo quo."
         }
      }
   ],
   "created_at": "2006-09-08T11:48:32-04:00",
   "created_by": "me@goa.design",
   "deceasedBoolean": false,
   "deceasedDateTime": "1977-02-20T12:15:51-05:00",
   "gender": "male",
   "href": "/patients/1",
   "id": 1,
   "identifier": [
      {
         "assigner": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "system": "http://sawayn.net/crystel",
         "type": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "use": "usual",
         "value": "Reprehenderit omnis cumque quia."
      },
      {
         "assigner": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "system": "http://sawayn.net/crystel",
         "type": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "use": "usual",
         "value": "Reprehenderit omnis cumque quia."
      }
   ],
   "link": [
      {
         "other": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "type": "See also"
      },
      {
         "other": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "type": "See also"
      }
   ],
   "managingOrganization": {
      "display": "Eaque et expedita omnis officiis illo.",
      "reference": "Nisi culpa."
   },
   "meta": {
      "lastUpdated": "1977-07-18T23:43:10-04:00",
      "profile": "http://cummerata.name/savanna_kulas",
      "security": {
         "code": "Consequatur ad.",
         "display": "Non reprehenderit et laboriosam.",
         "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
         "userSelected": false,
         "version": "Est ab est eveniet."
      },
      "tag": {
         "code": "Consequatur ad.",
         "display": "Non reprehenderit et laboriosam.",
         "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
         "userSelected": false,
         "version": "Est ab est eveniet."
      },
      "versionId": "Reprehenderit unde et ab."
   },
   "multipleBirthBoolean": false,
   "multipleBirthInteger": 3693525351942771919,
   "name": [
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      },
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      }
   ],
   "photo": [
      {
         "contentType": "Amet incidunt.",
         "creation": "1988-01-11T11:21:25-05:00",
         "data": "Sint iusto quo nostrum quaerat sapiente molestiae.",
         "hash": "Veritatis assumenda nihil quis.",
         "size": 3859331959323497509,
         "title": "Officiis labore ut quasi."
      },
      {
         "contentType": "Amet incidunt.",
         "creation": "1988-01-11T11:21:25-05:00",
         "data": "Sint iusto quo nostrum quaerat sapiente molestiae.",
         "hash": "Veritatis assumenda nihil quis.",
         "size": 3859331959323497509,
         "title": "Officiis labore ut quasi."
      }
   ],
   "telecom": [
      {
         "rank": 8423925307476269937,
         "system": "phone",
         "use": "work",
         "value": "Dignissimos placeat nemo quo."
      },
      {
         "rank": 8423925307476269937,
         "system": "phone",
         "use": "work",
         "value": "Dignissimos placeat nemo quo."
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp11.Run(c, args) },
	}
	tmp11.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp11.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "search",
		Short: `List all bottles in account optionally filtering by year`,
	}
	tmp12 := new(SearchPatientCommand)
	sub = &cobra.Command{
		Use:   `patient ["/nosh/patients"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "active": false,
   "address": [
      {
         "city": "Eaque vero quasi quod.",
         "country": "Enim sit porro asperiores aspernatur dolorem.",
         "distinct": "Modi provident earum aut quam dolorem sit.",
         "line": [
            "Est asperiores laboriosam consectetur voluptatem et."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "postalCode": "Consectetur ut.",
         "state": "Et dolorem.",
         "text": "Maxime eius rerum quia sunt neque.",
         "type": "both",
         "use": "work"
      }
   ],
   "animal": {
      "breed": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      },
      "genderStatus": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      },
      "species": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      }
   },
   "birthDate": "2000-05-04T09:23:10-04:00",
   "careProvider": {
      "display": "Eaque et expedita omnis officiis illo.",
      "reference": "Nisi culpa."
   },
   "communication": [
      {
         "careProvider": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "language": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "preferred": true
      }
   ],
   "contact": [
      {
         "address": {
            "city": "Eaque vero quasi quod.",
            "country": "Enim sit porro asperiores aspernatur dolorem.",
            "distinct": "Modi provident earum aut quam dolorem sit.",
            "line": [
               "Est asperiores laboriosam consectetur voluptatem et."
            ],
            "period": {
               "end": "1981-07-03T17:26:51-04:00",
               "start": "1998-04-13T16:02:45-04:00"
            },
            "postalCode": "Consectetur ut.",
            "state": "Et dolorem.",
            "text": "Maxime eius rerum quia sunt neque.",
            "type": "both",
            "use": "work"
         },
         "careProvider": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "gender": "other",
         "language": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "name": {
            "family": [
               "Repudiandae aut qui doloribus voluptate."
            ],
            "given": [
               "Tenetur ut fugit occaecati sequi amet."
            ],
            "period": {
               "end": "1981-07-03T17:26:51-04:00",
               "start": "1998-04-13T16:02:45-04:00"
            },
            "prefix": [
               "Similique nostrum nemo illum aperiam.",
               "Similique nostrum nemo illum aperiam.",
               "Similique nostrum nemo illum aperiam."
            ],
            "suffix": [
               "Qui veritatis quidem nihil."
            ],
            "use": "old"
         },
         "organization": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "preferred": false,
         "relationship": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "telecom": {
            "rank": 8423925307476269937,
            "system": "phone",
            "use": "work",
            "value": "Dignissimos placeat nemo quo."
         }
      }
   ],
   "created_at": "2006-09-08T11:48:32-04:00",
   "created_by": "me@goa.design",
   "deceasedBoolean": false,
   "deceasedDateTime": "1977-02-20T12:15:51-05:00",
   "gender": "male",
   "href": "/patients/1",
   "id": 1,
   "identifier": [
      {
         "assigner": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "system": "http://sawayn.net/crystel",
         "type": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "use": "usual",
         "value": "Reprehenderit omnis cumque quia."
      },
      {
         "assigner": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "system": "http://sawayn.net/crystel",
         "type": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "use": "usual",
         "value": "Reprehenderit omnis cumque quia."
      }
   ],
   "link": [
      {
         "other": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "type": "See also"
      },
      {
         "other": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "type": "See also"
      }
   ],
   "managingOrganization": {
      "display": "Eaque et expedita omnis officiis illo.",
      "reference": "Nisi culpa."
   },
   "meta": {
      "lastUpdated": "1977-07-18T23:43:10-04:00",
      "profile": "http://cummerata.name/savanna_kulas",
      "security": {
         "code": "Consequatur ad.",
         "display": "Non reprehenderit et laboriosam.",
         "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
         "userSelected": false,
         "version": "Est ab est eveniet."
      },
      "tag": {
         "code": "Consequatur ad.",
         "display": "Non reprehenderit et laboriosam.",
         "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
         "userSelected": false,
         "version": "Est ab est eveniet."
      },
      "versionId": "Reprehenderit unde et ab."
   },
   "multipleBirthBoolean": false,
   "multipleBirthInteger": 3693525351942771919,
   "name": [
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      },
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      }
   ],
   "photo": [
      {
         "contentType": "Amet incidunt.",
         "creation": "1988-01-11T11:21:25-05:00",
         "data": "Sint iusto quo nostrum quaerat sapiente molestiae.",
         "hash": "Veritatis assumenda nihil quis.",
         "size": 3859331959323497509,
         "title": "Officiis labore ut quasi."
      },
      {
         "contentType": "Amet incidunt.",
         "creation": "1988-01-11T11:21:25-05:00",
         "data": "Sint iusto quo nostrum quaerat sapiente molestiae.",
         "hash": "Veritatis assumenda nihil quis.",
         "size": 3859331959323497509,
         "title": "Officiis labore ut quasi."
      }
   ],
   "telecom": [
      {
         "rank": 8423925307476269937,
         "system": "phone",
         "use": "work",
         "value": "Dignissimos placeat nemo quo."
      },
      {
         "rank": 8423925307476269937,
         "system": "phone",
         "use": "work",
         "value": "Dignissimos placeat nemo quo."
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp12.Run(c, args) },
	}
	tmp12.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp12.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "secure",
		Short: `This action is secured with the jwt scheme`,
	}
	tmp13 := new(SecureUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/jwt"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp13.Run(c, args) },
	}
	tmp13.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp13.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "show",
		Short: `show action`,
	}
	tmp14 := new(ShowObservationCommand)
	sub = &cobra.Command{
		Use:   `Observation ["/nosh/patients/PATIENTID/observation/OBSERVATIONID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp14.Run(c, args) },
	}
	tmp14.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp14.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp15 := new(ShowUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/USERID"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp15.Run(c, args) },
	}
	tmp15.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp15.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "signin",
		Short: `Creates a valid JWT`,
	}
	tmp16 := new(SigninUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/jwt/signin"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "password": "Quibusdam soluta officiis occaecati odit cupiditate dolorem.",
   "username": "jim"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp16.Run(c, args) },
	}
	tmp16.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp16.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "signup",
		Short: `Signup user`,
	}
	tmp17 := new(SignupUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/jwt/signup"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "address_city": "Carmel",
   "address_line": "533 Worth Ct",
   "address_postal_code": 46032,
   "address_state": "IN",
   "email": "jim.smith@gmail.com",
   "first_name": "Jim",
   "last_name": "Smith",
   "password": "Doloremque assumenda et eum voluptatem laboriosam omnis.",
   "username": "jim"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp17.Run(c, args) },
	}
	tmp17.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp17.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "unsecure",
		Short: `This action does not require auth`,
	}
	tmp18 := new(UnsecureUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/jwt/unsecure"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp18.Run(c, args) },
	}
	tmp18.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp18.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "update",
		Short: `update action`,
	}
	tmp19 := new(UpdatePatientCommand)
	sub = &cobra.Command{
		Use:   `patient ["/nosh/patients/PATIENTID"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "name": [
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp19.Run(c, args) },
	}
	tmp19.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp19.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp20 := new(UpdateUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/nosh/users/USERID"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "email": "jim.smith@gmail.com",
   "password": "Reprehenderit molestiae sapiente dolor suscipit."
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp20.Run(c, args) },
	}
	tmp20.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp20.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "vread",
		Short: `Retrieve patient with given id. IDs 1 and 2 pre-exist in the system.`,
	}
	tmp21 := new(VreadPatientCommand)
	sub = &cobra.Command{
		Use:   `patient ["/nosh/patients/PATIENTID/_history/vid"]`,
		Short: `This resource uses JWT to secure its endpoints`,
		Long: `This resource uses JWT to secure its endpoints

Payload example:

{
   "active": false,
   "address": [
      {
         "city": "Eaque vero quasi quod.",
         "country": "Enim sit porro asperiores aspernatur dolorem.",
         "distinct": "Modi provident earum aut quam dolorem sit.",
         "line": [
            "Est asperiores laboriosam consectetur voluptatem et."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "postalCode": "Consectetur ut.",
         "state": "Et dolorem.",
         "text": "Maxime eius rerum quia sunt neque.",
         "type": "both",
         "use": "work"
      }
   ],
   "animal": {
      "breed": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      },
      "genderStatus": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      },
      "species": {
         "coding": [
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            },
            {
               "code": "Consequatur ad.",
               "display": "Non reprehenderit et laboriosam.",
               "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
               "userSelected": false,
               "version": "Est ab est eveniet."
            }
         ],
         "text": "Consectetur aliquam consequatur rerum."
      }
   },
   "birthDate": "2000-05-04T09:23:10-04:00",
   "careProvider": {
      "display": "Eaque et expedita omnis officiis illo.",
      "reference": "Nisi culpa."
   },
   "communication": [
      {
         "careProvider": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "language": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "preferred": true
      }
   ],
   "contact": [
      {
         "address": {
            "city": "Eaque vero quasi quod.",
            "country": "Enim sit porro asperiores aspernatur dolorem.",
            "distinct": "Modi provident earum aut quam dolorem sit.",
            "line": [
               "Est asperiores laboriosam consectetur voluptatem et."
            ],
            "period": {
               "end": "1981-07-03T17:26:51-04:00",
               "start": "1998-04-13T16:02:45-04:00"
            },
            "postalCode": "Consectetur ut.",
            "state": "Et dolorem.",
            "text": "Maxime eius rerum quia sunt neque.",
            "type": "both",
            "use": "work"
         },
         "careProvider": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "gender": "other",
         "language": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "name": {
            "family": [
               "Repudiandae aut qui doloribus voluptate."
            ],
            "given": [
               "Tenetur ut fugit occaecati sequi amet."
            ],
            "period": {
               "end": "1981-07-03T17:26:51-04:00",
               "start": "1998-04-13T16:02:45-04:00"
            },
            "prefix": [
               "Similique nostrum nemo illum aperiam.",
               "Similique nostrum nemo illum aperiam.",
               "Similique nostrum nemo illum aperiam."
            ],
            "suffix": [
               "Qui veritatis quidem nihil."
            ],
            "use": "old"
         },
         "organization": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "preferred": false,
         "relationship": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "telecom": {
            "rank": 8423925307476269937,
            "system": "phone",
            "use": "work",
            "value": "Dignissimos placeat nemo quo."
         }
      }
   ],
   "created_at": "2006-09-08T11:48:32-04:00",
   "created_by": "me@goa.design",
   "deceasedBoolean": false,
   "deceasedDateTime": "1977-02-20T12:15:51-05:00",
   "gender": "male",
   "href": "/patients/1",
   "id": 1,
   "identifier": [
      {
         "assigner": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "system": "http://sawayn.net/crystel",
         "type": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "use": "usual",
         "value": "Reprehenderit omnis cumque quia."
      },
      {
         "assigner": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "system": "http://sawayn.net/crystel",
         "type": {
            "coding": [
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               },
               {
                  "code": "Consequatur ad.",
                  "display": "Non reprehenderit et laboriosam.",
                  "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
                  "userSelected": false,
                  "version": "Est ab est eveniet."
               }
            ],
            "text": "Consectetur aliquam consequatur rerum."
         },
         "use": "usual",
         "value": "Reprehenderit omnis cumque quia."
      }
   ],
   "link": [
      {
         "other": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "type": "See also"
      },
      {
         "other": {
            "display": "Eaque et expedita omnis officiis illo.",
            "reference": "Nisi culpa."
         },
         "type": "See also"
      }
   ],
   "managingOrganization": {
      "display": "Eaque et expedita omnis officiis illo.",
      "reference": "Nisi culpa."
   },
   "meta": {
      "lastUpdated": "1977-07-18T23:43:10-04:00",
      "profile": "http://cummerata.name/savanna_kulas",
      "security": {
         "code": "Consequatur ad.",
         "display": "Non reprehenderit et laboriosam.",
         "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
         "userSelected": false,
         "version": "Est ab est eveniet."
      },
      "tag": {
         "code": "Consequatur ad.",
         "display": "Non reprehenderit et laboriosam.",
         "system": "Explicabo voluptatibus quia laboriosam tenetur magni.",
         "userSelected": false,
         "version": "Est ab est eveniet."
      },
      "versionId": "Reprehenderit unde et ab."
   },
   "multipleBirthBoolean": false,
   "multipleBirthInteger": 3693525351942771919,
   "name": [
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      },
      {
         "family": [
            "Repudiandae aut qui doloribus voluptate."
         ],
         "given": [
            "Tenetur ut fugit occaecati sequi amet."
         ],
         "period": {
            "end": "1981-07-03T17:26:51-04:00",
            "start": "1998-04-13T16:02:45-04:00"
         },
         "prefix": [
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam.",
            "Similique nostrum nemo illum aperiam."
         ],
         "suffix": [
            "Qui veritatis quidem nihil."
         ],
         "use": "old"
      }
   ],
   "photo": [
      {
         "contentType": "Amet incidunt.",
         "creation": "1988-01-11T11:21:25-05:00",
         "data": "Sint iusto quo nostrum quaerat sapiente molestiae.",
         "hash": "Veritatis assumenda nihil quis.",
         "size": 3859331959323497509,
         "title": "Officiis labore ut quasi."
      },
      {
         "contentType": "Amet incidunt.",
         "creation": "1988-01-11T11:21:25-05:00",
         "data": "Sint iusto quo nostrum quaerat sapiente molestiae.",
         "hash": "Veritatis assumenda nihil quis.",
         "size": 3859331959323497509,
         "title": "Officiis labore ut quasi."
      }
   ],
   "telecom": [
      {
         "rank": 8423925307476269937,
         "system": "phone",
         "use": "work",
         "value": "Dignissimos placeat nemo quo."
      },
      {
         "rank": 8423925307476269937,
         "system": "phone",
         "use": "work",
         "value": "Dignissimos placeat nemo quo."
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp21.Run(c, args) },
	}
	tmp21.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp21.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)

	dl := new(DownloadCommand)
	dlc := &cobra.Command{
		Use:   "download [PATH]",
		Short: "Download file with given path",
		RunE: func(cmd *cobra.Command, args []string) error {
			return dl.Run(c, args)
		},
	}
	dlc.Flags().StringVar(&dl.OutFile, "out", "", "Output file")
	app.AddCommand(dlc)
}

func intFlagVal(name string, parsed int) *int {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func float64FlagVal(name string, parsed float64) *float64 {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func boolFlagVal(name string, parsed bool) *bool {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func stringFlagVal(name string, parsed string) *string {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func hasFlag(name string) bool {
	for _, arg := range os.Args[1:] {
		if strings.HasPrefix(arg, "--"+name) {
			return true
		}
	}
	return false
}

func jsonVal(val string) (*interface{}, error) {
	var t interface{}
	err := json.Unmarshal([]byte(val), &t)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func jsonArray(ins []string) ([]interface{}, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []interface{}
	for _, id := range ins {
		val, err := jsonVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, val)
	}
	return vals, nil
}

func timeVal(val string) (*time.Time, error) {
	t, err := time.Parse(time.RFC3339, val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func timeArray(ins []string) ([]time.Time, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []time.Time
	for _, id := range ins {
		val, err := timeVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func uuidVal(val string) (*uuid.UUID, error) {
	t, err := uuid.FromString(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func uuidArray(ins []string) ([]uuid.UUID, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []uuid.UUID
	for _, id := range ins {
		val, err := uuidVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func float64Val(val string) (*float64, error) {
	t, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func float64Array(ins []string) ([]float64, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []float64
	for _, id := range ins {
		val, err := float64Val(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func boolVal(val string) (*bool, error) {
	t, err := strconv.ParseBool(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func boolArray(ins []string) ([]bool, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []bool
	for _, id := range ins {
		val, err := boolVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

// Run downloads files with given paths.
func (cmd *DownloadCommand) Run(c *client.Client, args []string) error {
	var (
		fnf func(context.Context, string) (int64, error)
		fnd func(context.Context, string, string) (int64, error)

		rpath   = args[0]
		outfile = cmd.OutFile
		logger  = goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
		ctx     = goa.WithLogger(context.Background(), logger)
		err     error
	)

	if rpath[0] != '/' {
		rpath = "/" + rpath
	}
	if rpath == "/ui" {
		fnf = c.DownloadUI
		if outfile == "" {
			outfile = "index.html"
		}
		goto found
	}
	if rpath == "/swagger.json" {
		fnf = c.DownloadSwaggerJSON
		if outfile == "" {
			outfile = "swagger.json"
		}
		goto found
	}
	if strings.HasPrefix(rpath, "/js/") {
		fnd = c.DownloadJs
		rpath = rpath[4:]
		if outfile == "" {
			_, outfile = path.Split(rpath)
		}
		goto found
	}
	return fmt.Errorf("don't know how to download %s", rpath)
found:
	ctx = goa.WithLogContext(ctx, "file", outfile)
	if fnf != nil {
		_, err = fnf(ctx, outfile)
	} else {
		_, err = fnd(ctx, rpath, outfile)
	}
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	return nil
}

// Run makes the HTTP request corresponding to the ReadAllergyIntoleranceCommand command.
func (cmd *ReadAllergyIntoleranceCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v/allergy.intolerance/%v.intoleranceID", cmd.PatientID, url.QueryEscape(cmd.Allergy))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp22 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp22, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.ReadAllergyIntolerance(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp22, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type), intFlagVal("allergy.intoleranceID", cmd.AllergyIntoleranceID))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ReadAllergyIntoleranceCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var allergy string
	cc.Flags().StringVar(&cmd.Allergy, "allergy", allergy, ``)
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
	var allergyIntoleranceID int
	cc.Flags().IntVar(&cmd.AllergyIntoleranceID, "allergy.intoleranceID", allergyIntoleranceID, ``)
}

// Run makes the HTTP request corresponding to the ReadNutritionRequestCommand command.
func (cmd *ReadNutritionRequestCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v/nutrition.requests/%v", cmd.PatientID, cmd.NutritionRequestID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp23 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp23, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.ReadNutritionRequest(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp23, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ReadNutritionRequestCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var nutritionRequestID int
	cc.Flags().IntVar(&cmd.NutritionRequestID, "nutrition_requestID", nutritionRequestID, ``)
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the ShowObservationCommand command.
func (cmd *ShowObservationCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v/observation/%v", cmd.PatientID, cmd.ObservationID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp24 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp24, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.ShowObservation(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp24, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowObservationCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var observationID int
	cc.Flags().IntVar(&cmd.ObservationID, "observationID", observationID, ``)
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the HealthHealthCommand command.
func (cmd *HealthHealthCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/_ah/health"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp25 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp25, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.HealthHealth(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp25, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *HealthHealthCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the AuthorizeOauth2ProviderCommand command.
func (cmd *AuthorizeOauth2ProviderCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/oauth2/auth"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp26 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp26, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.AuthorizeOauth2Provider(ctx, path, cmd.ClientID, cmd.ResponseType, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp26, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type), stringFlagVal("redirect_uri", cmd.RedirectURI), stringFlagVal("scope", cmd.Scope), stringFlagVal("state", cmd.State))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AuthorizeOauth2ProviderCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
	var clientID string
	cc.Flags().StringVar(&cmd.ClientID, "client_id", clientID, `The client identifier`)
	var redirectURI string
	cc.Flags().StringVar(&cmd.RedirectURI, "redirect_uri", redirectURI, `Redirection endpoint`)
	var responseType string
	cc.Flags().StringVar(&cmd.ResponseType, "response_type", responseType, `Value MUST be set to "code"`)
	var scope string
	cc.Flags().StringVar(&cmd.Scope, "scope", scope, `The scope of the access request`)
	var state string
	cc.Flags().StringVar(&cmd.State, "state", state, `An opaque value used by the client to maintain state between the request and callback`)
}

// Run makes the HTTP request corresponding to the GetTokenOauth2ProviderCommand command.
func (cmd *GetTokenOauth2ProviderCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/oauth2/token"
	}
	var payload client.TokenPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp27 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp27, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.GetTokenOauth2Provider(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp27, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetTokenOauth2ProviderCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the CreatePatientCommand command.
func (cmd *CreatePatientCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/patients"
	}
	var payload client.CreatePatientPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp28 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp28, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.CreatePatient(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp28, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreatePatientCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the DeletePatientCommand command.
func (cmd *DeletePatientCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v", cmd.PatientID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp29 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp29, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.DeletePatient(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp29, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeletePatientCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the ReadPatientCommand command.
func (cmd *ReadPatientCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v", cmd.PatientID)
	}
	var payload client.PatientPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp30 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp30, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.ReadPatient(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp30, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ReadPatientCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the SearchPatientCommand command.
func (cmd *SearchPatientCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/patients"
	}
	var payload client.PatientPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp31 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp31, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	var tmp32 *bool
	if cmd.Active != "" {
		var err error
		tmp32, err = boolVal(cmd.Active)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--active", "err", err)
			return err
		}
	}
	var tmp33 []time.Time
	if cmd.BirthDate != nil {
		var err error
		tmp33, err = timeArray(cmd.BirthDate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into []time.Time value", "flag", "--birthDate", "err", err)
			return err
		}
	}
	resp, err := c.SearchPatient(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp31, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type), tmp32, tmp33, stringFlagVal("gender", cmd.Gender), cmd.Name)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SearchPatientCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
	var active string
	cc.Flags().StringVar(&cmd.Active, "active", active, `Filter by active`)
	var birthDate []string
	cc.Flags().StringSliceVar(&cmd.BirthDate, "birthDate", birthDate, `Filter by birth date`)
	var gender string
	cc.Flags().StringVar(&cmd.Gender, "gender", gender, `Filter by gender`)
	var name []string
	cc.Flags().StringSliceVar(&cmd.Name, "name", name, `Filter by name`)
}

// Run makes the HTTP request corresponding to the UpdatePatientCommand command.
func (cmd *UpdatePatientCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v", cmd.PatientID)
	}
	var payload client.UpdatePatientPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp34 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp34, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.UpdatePatient(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp34, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdatePatientCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the VreadPatientCommand command.
func (cmd *VreadPatientCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/patients/%v/_history/vid", cmd.PatientID)
	}
	var payload client.PatientPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp35 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp35, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.VreadPatient(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp35, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *VreadPatientCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var patientID int
	cc.Flags().IntVar(&cmd.PatientID, "patientID", patientID, `Patient ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the CreateUserCommand command.
func (cmd *CreateUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/users"
	}
	var payload client.CreateUserPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp36 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp36, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.CreateUser(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp36, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the DeleteUserCommand command.
func (cmd *DeleteUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/users/%v", cmd.UserID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp37 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp37, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.DeleteUser(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp37, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var userID int
	cc.Flags().IntVar(&cmd.UserID, "userID", userID, `User ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the ListUserCommand command.
func (cmd *ListUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/users"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp38 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp38, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.ListUser(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp38, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the SecureUserCommand command.
func (cmd *SecureUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/users/jwt"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp39 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp39, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	var tmp40 *bool
	if cmd.Fail != "" {
		var err error
		tmp40, err = boolVal(cmd.Fail)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--fail", "err", err)
			return err
		}
	}
	resp, err := c.SecureUser(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp39, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type), tmp40)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SecureUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
	var fail string
	cc.Flags().StringVar(&cmd.Fail, "fail", fail, `Force auth failure via JWT validation middleware`)
}

// Run makes the HTTP request corresponding to the ShowUserCommand command.
func (cmd *ShowUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/users/%v", cmd.UserID)
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp41 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp41, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.ShowUser(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp41, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var userID int
	cc.Flags().IntVar(&cmd.UserID, "userID", userID, `User ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the SigninUserCommand command.
func (cmd *SigninUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/users/jwt/signin"
	}
	var payload client.SigninUserPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp42 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp42, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.SigninUser(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp42, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SigninUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the SignupUserCommand command.
func (cmd *SignupUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/users/jwt/signup"
	}
	var payload client.SignupUserPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp43 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp43, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.SignupUser(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp43, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SignupUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the UnsecureUserCommand command.
func (cmd *UnsecureUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/nosh/users/jwt/unsecure"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp44 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp44, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.UnsecureUser(ctx, path, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp44, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UnsecureUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}

// Run makes the HTTP request corresponding to the UpdateUserCommand command.
func (cmd *UpdateUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/nosh/users/%v", cmd.UserID)
	}
	var payload client.UpdateUserPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp45 *time.Time
	if cmd.LastUpdate != "" {
		var err error
		tmp45, err = timeVal(cmd.LastUpdate)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *time.Time value", "flag", "--_lastUpdate", "err", err)
			return err
		}
	}
	resp, err := c.UpdateUser(ctx, path, &payload, stringFlagVal("_contained", cmd.Contained), stringFlagVal("_containedType", cmd.ContainedType), intFlagVal("_count", cmd.Count), stringFlagVal("_elements", cmd.Elements), stringFlagVal("_has", cmd.Has), intFlagVal("_id", cmd.ID), stringFlagVal("_include", cmd.Include), tmp45, stringFlagVal("_list", cmd.List), stringFlagVal("_profile", cmd.Profile), stringFlagVal("_query", cmd.Query), stringFlagVal("_revinclude", cmd.Revinclude), stringFlagVal("_security", cmd.Security), stringFlagVal("_sort", cmd.Sort), stringFlagVal("_summary", cmd.Summary), stringFlagVal("_tag", cmd.Tag), stringFlagVal("_text", cmd.Text), stringFlagVal("_type", cmd.Type))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var userID int
	cc.Flags().IntVar(&cmd.UserID, "userID", userID, `User ID`)
	var contained string
	cc.Flags().StringVar(&cmd.Contained, "_contained", contained, ``)
	var containedType string
	cc.Flags().StringVar(&cmd.ContainedType, "_containedType", containedType, ``)
	var count int
	cc.Flags().IntVar(&cmd.Count, "_count", count, ``)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "_elements", elements, ``)
	var has string
	cc.Flags().StringVar(&cmd.Has, "_has", has, ``)
	var id int
	cc.Flags().IntVar(&cmd.ID, "_id", id, ``)
	var include string
	cc.Flags().StringVar(&cmd.Include, "_include", include, ``)
	var lastUpdate string
	cc.Flags().StringVar(&cmd.LastUpdate, "_lastUpdate", lastUpdate, ``)
	var list string
	cc.Flags().StringVar(&cmd.List, "_list", list, ``)
	var profile string
	cc.Flags().StringVar(&cmd.Profile, "_profile", profile, ``)
	var query string
	cc.Flags().StringVar(&cmd.Query, "_query", query, ``)
	var revinclude string
	cc.Flags().StringVar(&cmd.Revinclude, "_revinclude", revinclude, ``)
	var security string
	cc.Flags().StringVar(&cmd.Security, "_security", security, ``)
	var sort string
	cc.Flags().StringVar(&cmd.Sort, "_sort", sort, ``)
	var summary string
	cc.Flags().StringVar(&cmd.Summary, "_summary", summary, ``)
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "_tag", tag, ``)
	var text string
	cc.Flags().StringVar(&cmd.Text, "_text", text, ``)
	var type_ string
	cc.Flags().StringVar(&cmd.Type, "_type", type_, ``)
}
